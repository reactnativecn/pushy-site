{"/docs/api":{"title":"API参考","data":{"javascript-方法#JavaScript 方法":"","new-pushyoptions-pushyoptions#new Pushy(options: PushyOptions)":"创建 Pushy 热更新服务实例，其构造参数如下：\ninterface PushyOptions {\n  // 必填，通过pushy createApp或selectApp命令，或在网页管理端获取\n  appKey: string;\n  // 自定义日志输出，也可用于上报统计数据\n  logger?: ({ type, data }: { type: EventType; data: EventData }) => void;\n  // 触发自动检查更新的策略\n  checkStrategy?:\n    | \"onAppStart\" // 仅在app启动时\n    | \"onAppResume\" // 仅在app从后台切换到前台时\n    | \"both\"; // 默认值，同时包含前两个场景\n    | null; // 不自动检查更新，必须手动调用checkUpdate方法，此选项需 v10.4.2+ 版本\n  // 自动下载和应用更新的策略\n  updateStrategy?:\n    | \"alwaysAlert\" // 调试环境（__DEV__）默认值，使用系统默认的alert页面提示热更且会在有报错时弹出提示\n    | \"alertUpdateAndIgnoreError\" // 生产环境默认值，在有热更时使用系统默认的alert页面提示热更，但不弹出任何报错提示\n    | \"silentAndNow\" // 自动静默下载并立刻应用热更\n    | \"silentAndLater\"; // 自动静默下载，但仅在用户退出app后重启时应用更新\n    | null; // 不自动下载和应用更新，如需自定义热更界面请选择此项\n  // 是否在热更重启后自动标记为成功，默认为true\n  // 一般情况下不建议手动标记\n  autoMarkSuccess?: boolean;\n  // 是否在若干ms后自动清除最后的报错，默认为不清除\n  dismissErrorAfter?: number;\n  // 是否在开发环境中检查热更，默认为false。如需在开发环境中调试热更，请打开此选项。\n  // 但即便打开此选项，也仅能检查、下载热更，并不能实际应用热更。实际应用热更必须在release包中进行。\n  // 此选项需 v10.4.2+ 版本\n  debug?: boolean;\n  // 是否在调用 checkUpdate 和 downloadUpdate 时抛出错误，默认为不抛出错误，通过 lastError 获取错误信息\n  // 启用后可以使用 try catch 语句 捕获错误，同时 lastError 也仍然可用\n  // try {\n  //   await checkUpdate();\n  // } catch (e) {\n  //   console.error(e);\n  // }\n  // 此选项需 v10.15.2+ 版本\n  throwError?: boolean;\n  // 在检查更新前执行，返回 false 则取消检查更新\n  // 此选项需 v10.12.0+ 版本\n  beforeCheckUpdate?: () => Promise<boolean>;\n  // 在下载更新前执行，返回 false 则取消下载更新，可以配合自定义的 metaInfo 做一些条件控制\n  // 此选项需 v10.12.0+ 版本\n  beforeDownloadUpdate?: (info: UpdateInfo) => Promise<boolean>;\n}\n// 日志事件类型\ntype EventType =\n  // 更新失败，重启后发生回滚\n  | \"rollback\"\n  // 检查更新时报错\n  | \"errorChecking\"\n  // 正在发起检查\n  | \"checking\"\n  // 正在下载更新\n  | \"downloading\"\n  // 更新失败\n  | \"errorUpdate\"\n  // 更新成功\n  | \"markSuccess\"\n  // 下载apk\n  | \"downloadingApk\"\n  // 下载apk前申请存储权限被用户拒绝\n  | \"rejectStoragePermission\"\n  // 下载apk前申请存储权限发生错误\n  | \"errorStoragePermission\"\n  // 下载apk时发生错误\n  | \"errorDownloadAndInstallApk\";\n// 日志事件数据\ninterface EventData {\n  // 当前已完成的热更hash值，如尚未热更则为空字符串\n  currentVersion: string;\n  // 客户端版本信息\n  cInfo: {\n    rnu: string; // 当前 react-native-update 版本\n    rn: string; // 当前 react-native 版本\n    os: string; // 当前操作系统及版本\n    uuid: string; // 用户标识符\n  };\n  // 客户端原生版本号\n  packageVersion: string;\n  // 编译时间戳\n  buildTime: number;\n  // 报错相关的信息\n  message?: string;\n  // 发生回滚的版本hash值\n  rolledBackVersion?: string;\n  // 更新失败的新版本hash值\n  newVersion?: string;\n  // 其他一些数据\n  [key: string]: any;\n}","useupdate#useUpdate()":"热更相关的工具函数。此方法也可使用别名 usePushy 引入。\n注意，在使用 <UpdateProvider> 的当前组件（一般是根组件）中无法直接调用useUpdate，只有当前组件的子组件才能调用。\nconst {\n  checkUpdate,\n  switchVersion,\n  switchVersionLater,\n  markSuccess,\n  dismissError,\n  downloadUpdate,\n  downloadAndInstallApk,\n  getCurrentVersionInfo,\n  parseTestQrCode,\n  currentHash,\n  packageVersion,\n  client,\n  progress,\n  updateInfo,\n  lastError,\n} = useUpdate();\n其类型定义和功能如下：\ninterface UpdateContext {\n  // 检查更新（注意在 v10.26.0 版本之前，`checkUpdate`方法本身没有返回值，只能从`usePushy()`返回的`updateInfo`中获取）\n  checkUpdate: () => Promise<void | UpdateInfo>;\n  // 下载热更完成后调用，立即重启切换新版本\n  switchVersion: () => void;\n  // 下载热更完成后调用，用户手动重启app后切换新版本（静默更新）\n  switchVersionLater: () => void;\n  // 热更完成重启后，手动标记热更完成\n  markSuccess: () => void;\n  // 清除最后的报错状态\n  dismissError: () => void;\n  // 下载热更, v10.16.0+ 版本返回值为`boolean`，表示是否下载成功\n  downloadUpdate: () => Promise<boolean | void>;\n  // 下载并安装apk\n  downloadAndInstallApk: (url: string) => Promise<void>;\n  // 获取当前已热更版本的信息\n  getCurrentVersionInfo: () => Promise<{\n    name?: string;\n    description?: string;\n    metaInfo?: string;\n  }>;\n  // 解析测试二维码，此方法需 v10.11.2+ 版本\n  parseTestQrCode: (qrCode: string) => void;\n  // 当前的版本hash\n  currentHash: string;\n  // 当前的原生版本号\n  packageVersion: string;\n  // 当前的pushy热更服务实例\n  client?: Pushy;\n  // 下载开始后的进度数据\n  progress?: {\n    hash: string;\n    // 已下载的字节数\n    received: number;\n    // 待下载的总字节数\n    total: number;\n  };\n  // 热更相关信息\n  updateInfo?: {\n    // 已是最新版本，无需热更\n    upToDate?: true;\n    // 当前原生版本已过期，需要下载新的原生版本\n    expired?: true;\n    // 在pushy网页管理端设置的原生版本下载地址\n    downloadUrl?: string;\n    // 是否存在新的热更\n    update?: true;\n    // 新热更的版本名称\n    name?: string;\n    // 新热更的hash值\n    hash?: string;\n    // 新热更的更新说明\n    description?: string;\n    // 新热更携带的额外元数据\n    metaInfo?: string;\n    // 当前热更是否已暂停\n    paused?:\n      | \"app\" // 当前应用所有原生版本暂停\n      | \"package\"; // 仅当前原生版本暂停\n    // 其他信息\n    message?: string;\n  };\n  // 检查、下载、应用热更等过程中的最新一次报错\n  lastError?: Error;\n}","async-function-checkupdate#async function checkUpdate()":"触发更新检查，返回updateInfo（注意在 v10.26.0 版本之前，checkUpdate方法本身没有返回值，只能从usePushy()返回的updateInfo中获取），返回值有三种情形：\n{expired: true}：该应用原生包已过期（三种情况：1. 主动设置为过期状态，2. 主动删除，3. 从未上传），需要引导用户下载或跳转到应用市场(需要在网页管理端设置中填写downloadUrl)。如需在应用内执行 apk 更新，还需配置安装权限。\n{\n    expired: true,\n    downloadUrl: 'http://appstore/downloadUrl',\n}\n{upToDate: true}：当前已经更新到最新，无需进行更新。\n{update: true}：当前有新版本可以更新。name、description字段可以用于展示给用户版本号，更新内容等信息，而metaInfo字段则可以根据你的需求自定义一些标记(如是否静默更新、是否强制更新等等，自己根据标记的属性做一些条件流程控制)，具体用法可参考场景实践。另外还有几个字段，包含了热更新文件的下载地址，\n{\n    update: true,\n    name: '1.0.3-rc',\n    hash: 'hash',\n    description: '添加聊天功能\\n修复商城页面BUG',\n    metaInfo: '{\"silent\":true}',\n    pdiffUrl: 'http://update-packages.reactnative.cn/hash',\n    diffUrl: 'http://update-packages.reactnative.cn/hash',\n}","async-function-downloadupdate#async function downloadUpdate()":"下载热更包。仅当update:true时实际进行下载。会更新progress数据。v10.16.0+ 版本返回值为boolean，表示是否下载成功。","async-function-downloadandinstallapkurl#async function downloadAndInstallApk(url)":"下载更新的 apk 包并直接安装。url必须为可直接下载到 apk 文件的地址。注意要使用这个功能还需要在AndroidManifest.xml中手动添加安装权限，如果需要考虑 Android 7.0 以下的客户，则还需要添加外部存储权限。\n<uses-permission android:name=\"android.permission.REQUEST_INSTALL_PACKAGES\" />\n<!-- 如果需要考虑Android 7.0以下的客户，则还需要添加外部存储权限 -->\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n注意某些应用市场可能会因为上述权限拒绝应用上架。去掉上述两个权限并不影响热更新功能。","function-marksuccess#function markSuccess()":"一般情况下请勿手动调用此函数。 调用此函数作为更新成功的标记（否则下次启动会默认失败自动回滚）。","async-function-getcurrentversioninfo#async function getCurrentVersionInfo()":"获取当前已热更版本的信息（如尚未热更过则返回空对象）。返回值示例：\n{\n    name: '1.0.3-rc',\n    description: '添加聊天功能\\n修复商城页面BUG',\n    metaInfo: '{\"silent\":true}',\n}","function-switchversion#function switchVersion()":"立即重启应用，并加载已经下载完毕的版本。","function-switchversionlater#function switchVersionLater()":"在下一次启动应用的时候加载已经下载完毕的版本。","function-parsetestqrcodeqrcode-string#function parseTestQrCode(qrCode: string)":"解析测试二维码，一般用于给 QA 人员测试热更新。如果在应用中已有扫码功能，则可以在应用中扫描 pushy 后台的测试二维码来测试任意版本的热更包。注意使用此方法，上述界面中的\"使用 Deep Link\"选项 请不要 勾选。代码示例：\n<Camera\n  onReadCode={({ nativeEvent: { codeStringValue } }) => {\n    // 识别到二维码后先关闭相机\n    setShowCamera(false);\n    // 先解析是否是pushy的测试二维码\n    if (parseTestQrCode(codeStringValue)) {\n      // 如果是pushy的测试二维码，则不再做其他业务扫码逻辑\n      return;\n    }\n    // 如果不是，继续处理其他业务扫码逻辑\n  }}\n/>","android-方法#Android 方法":"","updatecontextsetcustominstancemanagerreactinstancemanager-instancemanager#UpdateContext.setCustomInstanceManager(ReactInstanceManager instanceManager)":"如果是集成/混编 Android 方案，则可以使用此方法传入你自行创建的 ReactInstanceManager。自v5.5.8版本起可用。示例：\nimport cn.reactnative.modules.update.UpdateContext\nmReactInstanceManager = ReactInstanceManager.builder()\n                // ...各种setter，但注意不要调用setBundleAssetName\n                .setJSBundleFile(UpdateContext.getBundleUrl(mContext, \"assets://index.android.bundle\"))\n                .build();\nUpdateContext.setCustomInstanceManager(mReactInstanceManager);"}},"/docs/bestpractice":{"title":"场景实践","data":{"优化原生和热更包体积#优化原生和热更包体积":"","ios-原生包优化ipa#iOS 原生包优化(ipa)":"对于同一份 archive（其版本号、编译时间和内置 bundle 已固定，不会受导出方式所影响），可以用不同选项多次导出 ipa，选择其中最小的上传到 pushy 服务器作为热更基准包。","android-原生包优化apk#Android 原生包优化(apk)":"apk 的优化主要考虑两个方向：\n启用 proguard 压缩混淆源码。但这一步可能导致一些使用反射的代码运行时报错，启用后需要充分测试每个页面和功能，以及需要阅读一些第三方关于 proguard 的特别设置说明。\n分开编译不同的 cpu 架构。找到android/app/build.gradle中的 cpu 架构部分，如下所示启用enable选项：\nsplits {\n    abi {\n        reset()\n-       enable enableSeparateBuildPerCPUArchitecture\n+       enable true        // 启用单独的 cpu 架构编译\n        universalApk false  // If true, also generate a universal APK\n    }\n}\n如此一来会在编译目录中输出多个 apk 文件，分发和上传到热更新服务时只需要使用app-arm64-v8a-release.apk文件，可以大幅减小 apk 的大小。","热更新包优化ppk#热更新包优化(ppk)":"热更新包的主要内容是 js 包和其所引用的静态资源（主要是图片）。\njs 包成分分析。可以借助一些第三方工具（如react-native-bundle-visualizer）来分析 js 文件中哪些占比较大，是否可以用其他库替换等（如 dayjs 替换 moment，lodash-es 替换 lodash）。\n图片优化。\n在保证体验的情况下，使用一些工具对图片进行裁剪压缩。\n如不需要图片的透明像素，可以考虑将 png 格式转为 jpg 格式。\n还可以进一步考虑压缩比更高的图片格式，例如 webp 格式（需要第三方原生插件例如react-native-webp-format），heif 格式（iOS 11 和 Android 10 以上原生支持）等。这里有个图片格式对比可供参考 https://compare.rokka.io/_compare/#heif=40&jpeg=80&webp=80&av1=40&width=800。","有很多渠道包需要热更如何操作比较方便#有很多渠道包需要热更，如何操作比较方便？":"如果渠道包的js代码和初始资源有差别（无论多么细微的差别都会生成不同的 jsbundle），那么只能单独生成 apk，分别上传和绑定。可以考虑写一些脚本自动调用 cli 来执行批量操作。\n如果渠道包的js代码和初始资源完全一致，可以考虑使用Flavor 构建，或其他一些动态生成渠道包的方案（比如腾讯的 VasDolly，美团的 walle等），这样所有的渠道包基于同一个基础 apk 生成（因而会有相同的编译时间戳和 jsbundle）。这样可以只用上传一个基础 apk，对此 apk 的热更操作可以对所有渠道包生效。\n如果您是高级版、专业版或大客户VIP版客户，也可以考虑在管理后台的应用设置中启用忽略编译时间戳。此选项仅对比版本号，不校验时间戳，可提供更宽容的热更策略，但可能消耗更多流量。","如何支持-aab-格式的原生包#如何支持 aab 格式的原生包？":"如果您需要使用 aab 格式的 android 原生包，那么可以在上传到 Google play 之后，在其控制台中下载转换后的 apk 格式（见下图），然后将这个 apk 包上传到热更新的后台，即可正常支持热更新。","ci-的集成#CI 的集成":"在开发环境中，每次 bundle 都会生成一个不同名字的 ppk 文件，这不利于持续集成(CI)系统的引入。要解决这个问题,你可以使用--output参数来指定输出 ppk 文件的名字和路径，便于进行自动发布。","测试发布与回滚#测试、发布与回滚":"自 v10.11.2 版本开始，可以使用以下两种快捷扫码方案来测试热更，而无需提前进行绑定：\n若应用启用了 DeepLink 功能\n代码中无需任何改动，只需在上述界面中勾选“使用 Deep Link”，填入您应用的协议名，例如\"pushy://\"，然后使用系统相机或系统内置的扫一扫功能扫码（注意不能使用微信扫码），即可自动调起应用并触发更新。\n若应用自带扫码功能\n请参考 parseTestQrCode 方法的说明。先发布一个测试包，再发布一个除了版本号以外均完全相同的正式包。例如，假设我们有一个正式包，版本为1.6.0，那么可以修改版本号重新打包一个1001.6.0，以一个明显不太正常的版本号来标识它是一个测试版本，同时后几位相同，可以表明它和某个正式版本存在关联（内容/依赖一致）。在每次往发布包发起热更新之前，先对测试包1001.6.0进行更新操作，基本测试通过之后，再在网页后台上将热更包重新绑定到正式包1.6.0上。如果在测试包中发现了重大问题，你就可以先进行修复，更新测试确认通过后再部署到正式线上环境。这样，可以最大程度的避免发生线上事故。万一确实发生线上事故需要回滚的话，先立即对原生包或者整个应用设置暂停热更，然后更改绑定到之前正常的版本，或者利用版本控制系统回滚代码到正常的状态，然后重新生成热更包并推送。","元信息meta-info的使用#元信息(Meta Info)的使用":"在发布热更新版本时，或者在网页端，你可以编辑版本的元信息。这是一段在检查更新时可以获得的字符串，你可以在其中按你所想的格式（一般建议用JSON 格式）保存一些信息。比如我们可以在元信息中约定字段标志silent，表示需要静默更新。当我们上传热更包填写 metainfo 时，以JSON 格式输入：\n{ \"silent\": true }\n请注意，我们并不对输入做任何格式校验和约束，请自行校验输入是否正确。\n此时在客户端检查更新时，能获取到我们刚刚输入的元信息，但它并不具备任何功能，只是一个字符串而已。所以我们其实需要预先在更新流程中加入对应的处理逻辑：\n// 调用 checkUpdate 获取 updateInfo\nif (updateInfo.expired) {\n  // ... 原生包版本过期，下载或跳转下载页面\n} else if (updateInfo.upToDate) {\n  // ... 没有更新，弹提示或忽略\n} else {\n  // 有更新，一般来说我们在这里给用户弹窗提示，让用户选择是否更新\n  // 那么静默更新的本质其实就是不弹窗，直接执行，所以可以在这里加入额外的判断流程\n  // ...\n}\n我们在原有的更新流程中加入元信息的读取和判断：\nlet metaInfo = {};\ntry {\n  // 注意 JSON 输入有可能有错误，需要用 try 语句来避免应用被带崩\n  metaInfo = JSON.parse(updateInfo.metaInfo);\n} catch (e) {\n  // 异常处理，忽略或上报？\n}\nif (metaInfo.silent) {\n  // 如果热更包携带有 silent 字段，不询问用户，直接执行更新\n  switchVersion();\n} else {\n  // 否则还是走之前的询问流程\n  // Alert.alert('提示', '检查到新的版本.......\n}\n又比如，可能某个版本包含一些重要的公告内容，所以还可以在上面插入一个公告字段等等。如何使用元信息，完全取决于您的想象力！"}},"/docs/cli":{"title":"命令行工具","data":{"安装#安装":"$ npm install -g react-native-update-cli","命令#命令":"","pushy-bundle#pushy bundle":"生成资源包\nplatform: ios|android 对应的平台\nentryFile: 入口脚本文件\nintermediaDir: 临时文件输出目录\noutput: 最终 ppk 文件输出路径\ndev: 是否打包开发版本\nsourcemap: 是否生成 sourcemap(需 cli 版本 1.11.0+)\nno-interactive: 不进行交互式提示\nrncli: 指定使用官方命令行打包 (需 cli 版本 1.40.0+)\nexpo: 指定使用 expo 的命令行打包 (需 cli 版本 1.40.0+)\ntaro: 指定使用 taro 的命令行打包 (需 cli 版本 1.40.0+)","pushy-parseipa-ipafile#pushy parseIpa [ipaFile]":"解析 ipa 文件并输出一些相关信息，如版本号，编译时间戳等。","pushy-parseapk-apkfile#pushy parseApk [apkFile]":"解析 apk 文件并输出一些相关信息，如版本号，编译时间戳等。","pushy-diff-originnext#pushy diff [origin][next]":"提供两个 ppk 文件，生成从 origin 到 next 版本的差异更新包。\noutput: diff 文件输出路径","pushy-difffromapk-apkfilenext#pushy diffFromApk [apkFile][next]":"提供一个 apk 文件和一个 ppk 文件，生成从 apk 文件到 next 版本的差异更新包。如果使用热更新开放平台，你不需要自己执行此命令。\noutput: diff 文件输出路径","pushy-difffromipa-ipafilenext#pushy diffFromIpa [ipaFile][next]":"提供一个 ipa 文件和一个 ppk 文件，生成从 ipa 文件到 next 版本的差异更新包。如果使用热更新开放平台，你不需要自己执行此命令。\noutput: diff 文件输出路径","pushy-login-emailpwd#pushy login [email][pwd]":"登录热更新开放平台。你需要先登录才能使用下面的命令。","pushy-logout#pushy logout":"登出并清除本地的登录信息","pushy-me#pushy me":"查看自己是否已经登录，以及昵称等信息。","pushy-createapp#pushy createApp":"创建应用并立刻绑定到当前工程。这项操作也可以在网页管理端进行。\nplatform: ios|android 对应的平台\nname: 应用名称\ndownloadUrl: 应用安装包的下载地址","pushy-deleteapp-appid#pushy deleteApp [appId]":"删除已有应用。所有已创建的应用包、热更新版本都会被同时删除。这项操作也可以在网页管理端进行。\nplatform: ios|android 对应的平台","pushy-apps#pushy apps":"查看当前已创建的全部应用。这项操作也可以在网页管理端进行。\nplatform: ios|android 对应的平台","pushy-selectapp-appid#pushy selectApp [appId]":"绑定应用到当前工程。\nplatform: ios|android 对应的平台","pushy-uploadipa-ipafile#pushy uploadIpa [ipaFile]":"上传 ipa 文件到开放平台。\nnote: 备注（cli 需 1.24.0 +）","pushy-uploadapk-apkfile#pushy uploadApk [apkFile]":"上传 apk 文件到开放平台。\nnote: 备注（cli 需 1.24.0 +）","pushy-packages#pushy packages":"查看已经上传的原生包。这项操作也可以在网页管理端进行。\nplatform: ios|android 对应的平台","pushy-publish-ppkfile#pushy publish [ppkFile]":"发布新的热更新版本（ppk 文件）。\nplatform: ios|android 对应的平台\nname: 当前热更新版本的名字(版本号)\ndescription: 当前热更新版本的描述信息，可以对用户进行展示\nmetaInfo: 当前热更新版本的元信息，可以用来保存一些额外信息，具体用法可参考场景实践。","pushy-versions#pushy versions":"分页列举可用的版本。这项操作也可以在网页管理端进行。\nplatform: ios|android 对应的平台","pushy-update#pushy update":"为一个原生包版本绑定一个热更新版本。这项操作也可以在网页管理端进行。以下参数中packageId，packageVersion，minPackageVersion和maxPackageVersion四选一即可。\nplatform: ios|android 对应的平台\nversionId: 要绑定的热更新版本 ID\npackageId: 要绑定的原生包 ID （四选一）\npackageVersion: 要绑定的原生包版本名（四选一，需 cli 版本 1.7.2+）\nminPackageVersion: 要绑定的最低原生包版本，大于等于此版本的将逐个绑定（四选一，需 cli 版本 1.27.0+）\nmaxPackageVersion: 要绑定的最高原生包版本，小于等于此版本的将逐个绑定（四选一，需 cli 版本 1.27.0+）\nrollout: 灰度发布范围（1-100），默认为 100 （需 cli 版本 1.31.0+）"}},"/docs/faq":{"title":"常见问题","data":{"":"如果本页面没能回答您的疑问，您可以去issues 区或 QQ 群 729013783 提问，或给我们发邮件。","业务问题#业务问题":"","热更新究竟能否上架#热更新究竟能否上架？":"您可能听说过各种说法，但大量实践表明，热更新目前能够顺利上架 AppStore 和其他各种应用市场。唯一需要注意的是，在审核期间请不要发布热更新，不要让审核人员看到各种更新相关的提示和弹窗，即可顺利通过。","是否可以在海外使用#是否可以在海外使用？":"可以的，国内外都有高速 CDN 节点。","哪些修改可以热更新哪些不能#哪些修改可以热更新？哪些不能？":"我们把对应用的修改分为两类：\n不可热更新 —— 原生修改，即所有需要编译后才能生效的修改：\n任何在 iOS 或者 Android 目录中的修改、增删。\n任何含有原生代码的第三方组件的更新、修改。\n可以热更新 —— 非原生修改，即所有无需编译，刷新即可生效的修改：\njs 代码修改，包括第三方纯 js 组件的更新、修改。\n可以在 js 代码中 require/import 的资源文件，例如图片。\n需要注意的是，即便资源文件可以热更新，但这些热更新后的资源文件会以file://协议的形式提供访问，某些读取资源文件的第三方可能并不支持file://协议。","我是否可以搭建自己的热更新服务#我是否可以搭建自己的热更新服务？":"你可以单独使用本组件的原生部分(不包括 js 模块)和命令行工具中的bundle、diff、diffFromIpa、diffFromApk四个功能。这些功能都不会使用我们的热更新服务，也无需注册或登录账号。但你可能要编写自己的 js 模块来与不同的热更新服务器通讯。","热更新成功完成但是重启后又回滚了是怎么回事#热更新成功完成，但是重启后又回滚了是怎么回事？":"可以正常更新，但是重启后回滚，一般有两种可能的情况：\n没有正确配置 bundleUrl\n（仅有 v10 以下版本存在此可能性，v10 及更高版本不存在此情况）没有正确调用 markSuccess\n如果你确定上述两个步骤都正确无误，请在issues 区给我们留言反馈。","热更新报错热更新已暂停原因编译时间戳与服务器记录不一致#热更新报错：“热更新已暂停，原因：编译时间戳与服务器记录不一致。”":"当您每次编译产生一个原生包时，其中都会记录一个编译时间戳buildTime(可以使用pushy parseIpa a.ipa或是pushy parseApk a.apk命令来查看)。如果您需要把这个包发给客户并希望使用热更新功能，那么就需要使用 upload 命令来上传到我们的服务器，而服务器端会记录这个包的版本号和编译时间戳以便后续比对记录。举例来说，假如我已经上传了一个 1.0 版本原生包（1A包），但后来由于种种原因我又重新打包了（1B包）但没有上传，这两个包有相同的版本号，但会有不同的编译时间戳。此时有几种可能的情况：\n我忘记上传过1A包，1B包没有实质更改且还没有客户安装。此时应当放弃1B包，只让客户下载安装1A包。\n我忘记上传过1A包，又生成了1B包且已有客户安装。此时1A包客户可以获取热更新，1B包客户无法获取热更新。要使两批客户都能获取热更新，要么想办法通知1B包客户装回1A包，要么重新发布一个高于1.0版本的原生包且上传到 pushy 服务器，并删除1.0版本的记录，此时1A包和1B包的客户都会收到版本过期需要下载新版本的通知。\n我知道上传过1A包，但我有原生方面的修改需要打了一个新的1B包。此时若将1B包上传到 pushy 服务器会提示版本验证错误，因为已经存在有相同的1.0版本。所以需要首先更改原生版本号再次打包，并首先将此新版本上传到服务器，然后分发给客户。这样1.0版本和新版本可以并存且都可以获得热更新。\n请谨记，任何时候生成原生包，请 1)先修改原生版本号，2)并上传到 pushy 服务器，才可以正常获得热更新。\n如果您是高级版、专业版或大客户VIP版客户，也可以考虑在管理后台的应用设置中启用忽略编译时间戳。此选项仅对比版本号，不校验时间戳，可提供更宽容的热更策略，但可能消耗更多流量，适合需要管理多个分发渠道的客户。","付费问题#付费问题":"","我应该选择哪个业务版本呢#我应该选择哪个业务版本呢？":"其实完全无需考虑，先从最高配额的专业版开始体验（新用户注册验证通过后，将自动获得 7 天专业版试用），各个版本的使用流程完全一致！当试用时间到期后，若当前版本的配额不能满足需求，可随时补差价升级到更高配额的版本。升级自动按天数计算差价，绝无额外费用。目前仅有一项额外的付费专用功能，即忽略编译时间戳设置（在管理后台的应用设置中），此选项仅对比版本号，不校验时间戳，可提供更宽容的热更策略，但可能消耗更多流量，适合需要管理多个分发渠道的客户。此功能目前仅支持高级版、专业版和大客户VIP版。","我可以试用付费版本先评估一下效果吗#我可以试用付费版本先评估一下效果吗？":"新用户注册验证通过后，将自动获得 7 天专业版试用。如您需要更长的评估时间，可将注册用户名、邮箱、公司（或个人）名称发送至 hi@charmlot.com ，标题注明“pushy 评估试用延长”，我们会为您酌情延长评估时间。","配额具体如何计算#配额具体如何计算？":"配额主要分为 4 种：\n可创建的应用数量，注意 iOS 和 Android 版本记做不同的应用。\n原生包数量及大小，不同应用分开计算。原生包指通过pushy uploadIpa/uploadApk命令上传到 Pushy 服务器上作为热更新起始版本的完整 apk/ipa 安装包。\n热更包数量及大小，不同应用分开计算。热更包指通过pushy bundle所命令生成的 ppk 文件。注意这不是用户实际下载的更新文件，用户下载的是通过比对生成的增量 diff 文件（比 ppk 文件要小得多）。\n每日总热更查询次数，所有应用累加计算。每次用户打开应用时，会向服务器查询是否有新的热更新。这个查询次数会被计入每日总热更查询次数。当日超过限额次数后，接口将不再返回新的热更新信息，直到次日重置。\n这里有一些对包大小的优化建议可供参考。\n以上 2、3 条为账户下每个应用单独计算，第 4 条为账户下所有应用累加计算。具体配额和费用由于运营成本可能会有调整，请以价格表页面为准。已购买的用户在续费前不受调整影响。","达到配额后还可以正常使用吗#达到配额后还可以正常使用吗？":"当应用、原生包、热更包数量达到配额限制后，您将无法执行相应的新增操作。但用户端仍可正常检查更新，下载已发布的更新。您可选择升级到更高配额，或是通过删除已不再使用的应用、原生包、热更包来使数量降低到配额以内，以便继续执行新增操作。\n若原生包、热更包大小超过限额，则会导致上传失败。您可以选择升级到更高配额，或是想办法进行精简优化。\n若当日热更检查次数超过限额，则会导致接口返回空数据。您可以选择升级到更高配额，或是优化热更策略，减少用户端检查更新的频率。","我可以单独升级某项配额吗#我可以单独升级某项配额吗？":"我们暂时无法为某个单项配额提供升级选项，请选择更高版本的配额。如果专业版配额仍然不能满足需求，请通过邮件 hi@charmlot.com 与我们联系，我们将根据您的个性化需求为您定制方案。","付费业务到期后不续费现有应用还能否正常使用#付费业务到期后不续费，现有应用还能否正常使用？":"到期后按免费版额度执行。如您现有应用已超出配额，则必须通过删除操作降低到配额以内，方可执行新的操作（如创建应用，上传热更等），但不影响用户获取之前已发布的热更。","如何获取付费的专人技术支持#如何获取付费的专人技术支持？":"请将您的用户名和订单截图发送至 hi@charmlot.com ，同时提供您希望的技术联系方式（QQ、微信等），核实后会有技术专员添加您为好友。","如何开具发票#如何开具发票？":"请将具体开票需求发送至 hi@charmlot.com ，并附上注册邮箱和订单截图。我们默认会回复普通电子发票到注册邮箱，类目为软件服务。如需指定接受邮箱或手机，请在邮件正文中注明。如需要邮寄纸质发票请注明邮寄地址，邮费为到付。\n如邮件发送后三个工作日内未收到回复，请联系 QQ 客服 34731408。","可以使用银行转账付款吗#可以使用银行转账付款吗？":"可以的。请对照价格表，将对应版本的款项转账至：\n公司名称\t武汉青罗网络科技有限公司\t账号\t8888888048825564\t开户行名称\t浙江网商银行\t开户地区\t浙江省杭州市\t支行名称\t浙江网商银行股份有限公司\t联行号\t323331000001\t\n转账完成后请截图发送至 hi@charmlot.com ，并写明注册邮箱，我们将在一个工作日内开通对应服务。","可以按月付款吗#可以按月付款吗？":"需要月付的客户请联系 QQ 客服 34731408，月付价格为年付价格 / 8。如标准版当前价格为 800 元每年，则月付价格为 100 元每月。\n月付客户需累计支付满 500 元后才能开具发票。大客户VIP版不支持月付。","大客户方案#大客户方案":"如果您的应用有大规模的活跃用户，日均所有应用累计总查询次数超过 100 万次，则建议选择我们专门针对大规模应用优化的大客户VIP版。\n大客户VIP版在应用数量、原生包数量、热更包数量等方面配额与专业版相同。当前价格如下表：\n服务版本\t日均总热更查询次数\t价格（元/年）\tVIP1\t1000 万次\t30000\tVIP2\t5000 万次\t60000\tVIP3\t1 亿次\t120000\tVIP4\t1 亿次以上\t请联系客服\t\n具体试用和对接请联系 QQ 客服 34731408"}},"/docs/getting-started":{"title":"安装配置","data":{"":"请注意，当前版本的api经过了完全重构，与之前的版本(v10.0以下)不兼容。如果你需要查看之前版本的文档，请点击这里\n首先你应该有一个基于 React Native 开发的应用，我们把具有 package.json 的目录叫做你的应用根目录。\n如果你还没有初始化应用，请参阅开始使用 React Native。我们假设你已经拥有了开发 React Native 应用的一切环境，包括Node.js、Xcode、Android SDK等等。","安装#安装":"在你的项目根目录下运行以下命令：\n# 先全局安装命令行工具，每台电脑只用装一次\nnpm i -g react-native-update-cli\n# 然后在项目目录中安装热更新模块\nnpm i react-native-update\n# 然后进入ios目录安装iOS模块\ncd ios && pod install\n如果下载极慢或者显示网络失败，请设置使用淘宝镜像 npx nrm use taobao\n注意请不要混用npm/yarn/pnpm等包管理器及对应的lock文件，团队成员请坚持使用同一包管理器，且仅保留统一格式的lock文件\n请记得，任意在 ios 和 android 目录下的修改，一定要重新编译（使用 npx\nreact-native run-ios 或 run-android 命令编译，或在 Xcode/Android Studio\n中重新编译）才能生效。","手动-link#手动 link":"如果 RN 版本 >= 0.60 则不需要此手动 link 步骤。\n注意：如果是混编 RN\n项目，或monorepo，或任何其他自定义的情况，由于自定义的配置可能不完整或不适应RN的目录结构，导致自动\nlink 的功能可能不能正常工作。此时即便 RN 版本 >= 0.60，你可能也需要执行手动\nlink 操作。","ios#iOS":"RN < 0.60且使用CocoaPods（推荐）\n在 ios/Podfile 中添加\npod 'react-native-update', path: '../node_modules/react-native-update'\n在项目的 ios 目录下运行pod install\n重新编译\nRN < 0.60且不使用CocoaPods\n在 XCode 中的 Project Navigator 里,右键点击Libraries ➜ Add Files to [你的工程名]\n进入node_modules ➜ react-native-update ➜ ios 并选中RCTPushy.xcodeproj`\n在 XCode 中的 project navigator 里,选中你的工程,在 Build Phases ➜ Link Binary With Libraries 中添加 libRCTPushy.a、libz.tbd、libbz2.1.0.tbd\n继续在Build Settings里搜索Header Search Path，添加$(SRCROOT)/../node_modules/react-native-update/ios，勾选recursive。\n在Build Phases添加一个New Run Script Phase运行脚本，内容如下\n#!/bin/bash\nset -x\nDEST=\"../node_modules/react-native-update/ios/\"\ndate +%s > \"$DEST/pushy_build_time.txt\"\n尝试编译一下，顺利的话就会在../node_modules/react-native-update/ios/文件夹下面生成一个pushy_build_time.txt文件。然后在Copy Bundle Resources里把生成的pushy_build_time.txt文件添加进去。","android#Android":"RN < 0.60 或其他不能自动 link 的情况\n在android/settings.gradle中添加如下代码:\ninclude ':react-native-update'\nproject(':react-native-update').projectDir = new File(rootProject.projectDir, \t'../node_modules/react-native-update/android')\n在android/app/build.gradle的 dependencies 部分增加如下代码:\nimplementation project(':react-native-update')\n打开android/app/src/main/java/[...]/MainApplication.java,\n在文件开头增加 import cn.reactnative.modules.update.UpdatePackage;\n在getPackages() 方法中增加 new UpdatePackage()(注意上一行可能要增加一个逗号)","配置-bundle-url#配置 Bundle URL":"注意此步骤无论任何版本，目前都需要手动配置。","ios-1#iOS":"在你的 AppDelegate.mm 或 AppDelegate.m 或 AppDelegate.swift 文件（不同 RN 版本可能后缀名不同）中增加如下代码：\n// ... 其它代码\n#import \"AppDelegate.h\"\n#import \"RCTPushy.h\"  // <-- import头文件，注意要放到if条件外面\n// 可能项目里有一些条件编译语句，例如有些版本RN自带的flipper\n// #if DEBUG\n// 注意**不要**在这里面引入\"RCTPushy.h\"\n// #import <FlipperKit/FlipperClient.h>\n// ...\n// #endif\n// rn 版本 >= 0.74 需要修改 bundleURL 方法\n- (NSURL *)bundleURL\n{\n#if DEBUG\n  // 原先DEBUG这里的写法不作修改(所以DEBUG模式下不可热更新)\n  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\"];\n#else\n  return [RCTPushy bundleURL];  // <--  把这里非DEBUG的情况替换为热更新bundle\n#endif\n}\n// rn 版本 < 0.74 需要修改sourceURLForBridge方法\n- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge\n{\n#if DEBUG\n  // 原先DEBUG这里的写法不作修改(所以DEBUG模式下不可热更新)\n  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\"];\n#else\n  return [RCTPushy bundleURL];  // <--  把这里非DEBUG的情况替换为热更新bundle\n#endif\n}\nimport UIKit\nimport React\nimport React_RCTAppDelegate\nimport ReactAppDependencyProvider\nimport react_native_update    // <-- 在这里引入，需要 pushy v10.22.0+ 版本\n@main\nclass AppDelegate: RCTAppDelegate {\n  // ... 其他代码\n  override func bundleURL() -> URL? {\n#if DEBUG\n    // 原先 DEBUG 这里的写法不作修改(所以 DEBUG 模式下不可热更新)\n    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: \"index\")\n#else\n    RCTPushy.bundleURL()  // <--  把这里非 DEBUG 的情况替换为热更新 bundle\n#endif\n  }\n}","android-1#Android":"在 MainApplication 中增加如下代码（如果是混编原生的项目或其他原因没有使用 ReactApplication，请使用此 api 集成)：\n// ... 其它代码\n// ↓↓↓请注意不要少了这句import\nimport cn.reactnative.modules.update.UpdateContext\n// ↑↑↑\nclass MainApplication : Application(), ReactApplication {\n  override val reactNativeHost: ReactNativeHost =\n      object : DefaultReactNativeHost(this) {\n        // ↓↓↓将下面这一段添加到 DefaultReactNativeHost 内部！\n        override fun getJSBundleFile(): String? {\n          return UpdateContext.getBundleUrl(this@MainApplication)\n        }\n        // ↑↑↑\n        // ...其他代码\n      }\n}\n// ... 其它代码\n// ↓↓↓请注意不要少了这句import\nimport cn.reactnative.modules.update.UpdateContext;\n// ↑↑↑\npublic class MainApplication extends Application implements ReactApplication {\n  private final ReactNativeHost mReactNativeHost =\n    // 老版本 RN 这里可能是 new ReactNativeHost(this)\n    new DefaultReactNativeHost(this) {\n    // ↓↓↓将下面这一段添加到 DefaultReactNativeHost 内部！\n    @Override\n    protected String getJSBundleFile() {\n        return UpdateContext.getBundleUrl(MainApplication.this);\n    }\n    // ↑↑↑\n    // ...其他代码\n  }\n}\n请记得，任意在 ios 和 android 目录下的修改，一定要重新编译（npx react-native\nrun-ios 或 run-android 命令编译，或在 Xcode/Android Studio\n中重新编译）才能生效。","禁用-android-的-crunch-优化#禁用 android 的 crunch 优化":"android 会在生成 apk 时自动对 png 图片进行压缩，此操作既耗时又影响增量补丁的生成。为了保证补丁能正常生成，您需要在android/app/build.gradle中关闭此操作：\n// 在 android/app/build.gradle 文件中\nandroid {\n    // ...\n    signingConfigs {\n      // ...\n    }\n    buildTypes {\n        release {\n            // ...\n            // 添加下面这行以禁用crunch\n            crunchPngs false\n        }\n    }\n}","禁用-aab-包的资源分割如果你需要在-google-play-上架#禁用 aab 包的资源分割（如果你需要在 Google Play 上架）":"如果你需要打 aab 包以在 Google Play 上架，则需要禁用 aab 包的资源分割：\n// 在 android/app/build.gradle 文件中\nandroid {\n    bundle {\n        density {\n            // 请禁用资源分割\n            // 否则热更后可能遇到图片无法显示的问题\n            enableSplit = false\n        }\n    }\n}","登录与创建应用#登录与创建应用":"首先请在 https://pushy-admin.reactnative.cn 注册帐号，然后在你的项目根目录下运行以下命令：\n$ pushy login\nemail: <输入你的注册邮箱>\npassword: <输入你的密码>\n这会在项目文件夹下创建一个.update文件，注意不要把这个文件上传到 Git 等 CVS 系统上。你可以在.gitignore末尾增加一行.update来忽略这个文件。登录之后可以创建应用。注意 iOS 平台和安卓平台需要分别创建：\n$ pushy createApp --platform ios\nApp Name: <输入应用名字>\n$ pushy createApp --platform android\nApp Name: <输入应用名字>\n两次输入的名字可以相同，这没有关系。\n如果你已经在网页端或者其它地方创建过应用，也可以直接选择应用：\n$ pushy selectApp --platform ios\n1) 鱼多多(ios)\n2) 招财旺(ios)\nTotal 2 ios apps\nEnter appId: <输入应用前面的编号>\n选择或者创建过应用后，你将可以在文件夹下看到update.json文件，其内容类似如下形式：\n{\n    \"ios\": {\n        \"appId\": 1,\n        \"appKey\": \"<一串随机字符串>\"\n    },\n    \"android\": {\n        \"appId\": 2,\n        \"appKey\": \"<一串随机字符串>\"\n    }\n}\n你可以安全的把update.json上传到 Git 等 CVS 系统上，与你的团队共享这个文件，它不包含任何敏感信息。当然，他们在使用任何功能之前，都必须首先输入pushy login进行登录。至此应用的创建/选择就已经成功了。下一步，你需要给代码添加相应的功能，请参阅代码集成。"}},"/docs/integration":{"title":"代码集成","data":{"":"请注意，当前版本的api经过了完全重构，与之前的版本(v10.0以下)不兼容。如果你需要查看之前版本的文档，请点击这里\n安装配置完成后，确定应用编译顺利通过，下面我们来进行代码集成。","获取-appkey#获取 appKey":"检查更新时必须提供你的appKey，这个值保存在update.json中（使用pushy createApp或pushy selectApp命令后会自动生成），并且根据平台不同而不同。你可以用如下的代码获取appKey：\nimport { Platform } from \"react-native\";\nimport _updateConfig from \"./update.json\";\nconst { appKey } = _updateConfig[Platform.OS];\n如果你不使用 pushy 命令行，也可以从网页端查看到两个应用 appKey，并根据平台的不同来选择。","初始化服务#初始化服务":"import { UpdateProvider, Pushy } from \"react-native-update\";\n// 唯一必填参数是appKey，其他选项请参阅 api 文档\nconst pushyClient = new Pushy({\n  appKey,\n  // 注意，默认情况下，在开发环境中不会检查更新\n  // 如需在开发环境中调试更新，请设置debug为true\n  // 但即便打开此选项，也仅能检查、下载热更，并不能实际应用热更。实际应用热更必须在release包中进行。\n  // debug: true\n});\n// 在根组件外加上 UpdateProvider 后导出\nexport default function Root() {\n  // 注意，在使用 UpdateProvider 的当前组件中，无法直接调用 useUpdate\n  // 只有当前组件的子组件才能调用 useUpdate\n  return (\n    <UpdateProvider client={pushyClient}>\n      {/* ↓ 整个应用的根组件放到 UpdateProvider 中 */}\n      <App />\n    </UpdateProvider>\n  );\n}\n如没有特别的自定义需求，那么到此热更新已经可以开始正常运作（如需在应用内执行 apk 更新，还需配置安装权限）。默认配置下，在 App 启动，以及从后台切换到前台时会触发更新检查，弹出提示的内容也固定。如需自定义触发时机，以及修改界面提示等，请参考下面的自定义更新界面。","自定义更新界面#自定义更新界面":"默认配置下，pushy 会以系统 alert 的形式来弹出更新提示，如需自定义更新界面，首先请关闭默认的 updateStrategy 更新策略，并打开 debug 选项以便调试：\nconst pushyClient = new Pushy({\n  appKey,\n+  updateStrategy: null,\n+  debug: true,\n});\n所有更新相关的数据可以通过一个单一的useUpdate()hook 函数来获取（此函数也有别名usePushy()），然后可以根据其提供的数据来自行渲染自定义的界面，如下面的例子：\nimport { useUpdate } from \"react-native-update\";\nimport { Icon, PaperProvider, Snackbar, Banner } from \"react-native-paper\";\nfunction App() {\n  const {\n    client,\n    checkUpdate,\n    downloadUpdate,\n    switchVersionLater,\n    switchVersion,\n    updateInfo,\n    packageVersion,\n    currentHash,\n    progress: { received, total } = {},\n  } = useUpdate();\n  const [showUpdateBanner, setShowUpdateBanner] = useState(false);\n  const [showUpdateSnackbar, setShowUpdateSnackbar] = useState(false);\n  const snackbarVisible = showUpdateSnackbar && updateInfo?.update;\n  return (\n    <View style={styles.container}>\n      <Text>\n        更新下载进度：{received} / {total}\n      </Text>\n      <Pressable onPress={checkUpdate}>\n        <Text>点击这里检查更新</Text>\n      </Pressable>\n      {snackbarVisible && (\n        <Snackbar\n          visible={true}\n          onDismiss={() => {\n            setShowUpdateSnackbar(false);\n          }}\n          action={{\n            label: \"更新\",\n            onPress: async () => {\n              setShowUpdateSnackbar(false);\n              if (await downloadUpdate()) {\n                setShowUpdateBanner(true);\n              }\n            },\n          }}\n        >\n          <Text>有新版本({updateInfo.name})可用，是否更新？</Text>\n        </Snackbar>\n      )}\n      <Banner\n        style={{ width: \"100%\", position: \"absolute\", top: 0 }}\n        visible={showUpdateBanner}\n        actions={[\n          {\n            label: \"立即重启\",\n            onPress: switchVersion,\n          },\n          {\n            label: \"下次再说\",\n            onPress: () => {\n              switchVersionLater();\n              setShowUpdateBanner(false);\n            },\n          },\n        ]}\n        icon={({ size }) => (\n          <Icon name=\"checkcircleo\" size={size} color=\"#00f\" />\n        )}\n      >\n        更新已完成，是否立即重启？\n      </Banner>\n    </View>\n  );\n}\n其中checkUpdate方法可以用来手动触发更新检查。检查后会返回updateInfo（注意在 v10.26.0 版本之前，checkUpdate方法本身没有返回值，只能从usePushy()返回的updateInfo中获取），有三种情况：\n{expired: true}：该应用原生包已过期（三种情况：1. 主动设置为过期状态，2. 主动删除，3. 从未上传），开发者应该在 pushy 的管理后台添加一个更新下载链接，并自行提示用户下载。如需在应用内执行 apk 更新，还需配置安装权限。\n{upToDate: true}：当前已经更新到最新，无需进行更新。\n{update: true}：当前有新版本可以更新。info 的name、description字段可以用于提示用户，而metaInfo字段则可以根据你的需求自定义其它属性(如是否静默更新、是否强制更新等等)，具体用法可参考场景实践。另外还有几个字段，包含了补丁包的下载地址等。 pushy 会首先尝试耗费流量更少的更新方式。\n当返回的updateInfo中update字段为 true 时，即可调用downloadUpdate方法来下载更新，此时可以获取到下载的进度数据progress。下载完成后可以调用switchVersion来立即重启更新，也可以使用switchVersionLater来标记下次启动时更新。","统计数据#统计数据":"初始化 Pushy 客户端时可以传入自定义的 logger 函数，其中可以自己记录日志或上报统计数据，比如下面的例子使用 Google Analytics 来上报事件：\nimport { getAnalytics, logEvent } from \"firebase/analytics\";\nconst analytics = getAnalytics();\nconst pushyClient = new Pushy({\n  appKey,\n  logger: ({ type, data }) => {\n    logEvent(analytics, \"pushy_\" + type, data);\n  },\n});\n以上提及的所有 api 的说明文档可在这里查看。现在，你的应用已经可以通过 pushy 服务检查版本并进行更新了。下一步，你可以开始尝试发布应用包和版本，请参阅发布热更新。"}},"/docs/publish":{"title":"发布热更新","data":{"":"现在你的应用已经具备了检测更新的功能，下面我们来尝试发布并更新它。流程可参考下图：\n流程总结如下：\n我们需要先打包一个原生 release 版本，在打包前请确保已集成了react-native-update并在调试过程中运行正常，安卓端关闭了crunchPngs设置，打包说明可参考iOS 打包和android 打包。打包完成后请使用pushy uploadIpa或者pushy uploadApk命令来把这个安装包上传到 pushy 服务器端，以作为之后热更差量对比的基准。同时请保留好这个安装包，上架和分发给用户所使用的安装包需要和服务器端完全一致。建议使用 git tag 功能来标记原生版本号（例如v1.0.0）。\n然后在基准版本之上迭代业务逻辑（增删 js 代码，增删图片等静态资源），使用pushy bundle命令来生成和发布热更新版本，而不需要重新打包。建议使用 git tag 功能来标记热更版本号（例如v1.0.1）。\n如果迭代过程中有原生方面的修改，则需要发布并上传新的原生基准版本（重复步骤 1，但需要设置不同的原生版本号）。可以只保留一个原生基准版本，也可以多版本同时维护。","发布原生基准版本#发布原生基准版本":"","ios#iOS":"首先参考文档-在设备上运行，确定你正在使用离线包。然后点击菜单。按照正常的发布流程打包.ipa文件：\nXcode 中运行设备选真机或 Generic iOS Device\n菜单中选择 Product - Archive\nArchive 完成后选择Export生成.ipa 文件\n然后运行如下命令上传到 pushy 服务器以供后续版本比对之用\n$ pushy uploadIpa <ipa后缀文件>\n此 ipa 的CFBundleShortVersionString字段(位于ios/项目名/Info.plist中)会被记录为原生版本号packageVersion。随后你可以选择往 AppStore 上传这个版本（可以重新 export 并调整相关选项，但请不要重新 archive），也可以先通过Test flight或蒲公英等渠道进行真机安装测试。请注意：暂不支持通过 Xcode 直接进行热更新测试。如果后续需要再次 archive 打包（例如修改原生代码或配置。如果只是修改 js 代码则不需要重新打包。），请先更改版本号，并在打包完成后再次uploadIpa到服务器端记录，否则后续生成的相同版本的原生包会由于编译时间戳不一致而无法获取热更新。","android#Android":"首先参考文档-打包 APK设置签名，然后在 android 文件夹下运行./gradlew assembleRelease或./gradlew aR，你就可以在android/app/build/outputs/apk/release/app-release.apk中找到你的应用包。\n如果你需要使用 aab 格式（android app bundle，google 市场专用）的包，请参考这里的做法将其转换为 apk 格式后再操作。\n然后运行如下命令\n$ pushy uploadApk android/app/build/outputs/apk/release/app-release.apk\n即可上传 apk 以供后续版本比对之用。此 apk 的versionName字段(位于android/app/build.gralde中)会被记录为原生版本号packageVersion。随后你可以选择往应用市场发布这个版本，也可以先往设备上直接安装这个 apk 文件以进行测试。如果后续需要再次打包（例如修改原生代码或配置。如果只是修改 js 代码则不需要重新打包。），请先更改版本号，并再次uploadApk到服务器端记录，否则后续生成的相同版本的原生包会由于编译时间戳不一致而无法获取热更新。","发布热更新版本#发布热更新版本":"你可以尝试修改一行代码(譬如将版本一修改为版本二)，然后使用pushy bundle --platform <ios|android>命令来生成新的热更新版本。\n如果你使用了较新版本的expo或其他没有index.js的框架，执行bundle命令时会报错。此时请手动创建一个index.js文件，在其中引用框架自身的入口文件即可。具体入口文件的路径如何，请参考框架的说明文档或者package.json中的main字段。例如针对expo的index.js可能是如下这样写：\nimport \"expo-router/entry\";\n$ pushy bundle --platform android\nBundling with React Native version:  0.22.2\n<各种进度输出>\nBundled saved to: build/output/android.1459850548545.ppk\nWould you like to publish it?(Y/N)\n如果想要立即上传，此时输入 Y。当然，你也可以在将来使用pushy publish --platform android build/output/android.1459850548545.ppk来上传刚才打包好的热更新包。\n  Uploading [========================================================] 100% 0.0s\nEnter version name: <输入热更新版本名字，如1.0.0-rc>\nEnter description: <输入热更新版本描述>\nEnter meta info: {\"ok\":1}\nOk.\nWould you like to bind packages to this version?(Y/N)\n此时版本已经提交到 pushy 服务，但用户暂时看不到此更新，你需要先将特定的原生包版本绑定到此热更新版本上。此时输入 Y 立即绑定，你也可以在将来使用pushy update --platform <ios|android>来对已上传的热更包和原生包进行绑定。除此以外，你还可以在网页端操作，简单的将对应的原生包版本拖到需要的热更新版本下即可。\n┌────────────┬──────────────────────────────────────┐\n│ Package Id │               Version                │\n├────────────┼──────────────────────────────────────┤\n│   46272    │ 2.0(normal)                          │\n├────────────┼──────────────────────────────────────┤\n│   45577    │ 1.0(normal)                          │\n└────────────┴──────────────────────────────────────┘\n共 2 个包\n输入原生包 id: 46272\n版本绑定完毕后，服务器会在几秒内生成差量补丁，客户端就可以获取到更新了。后续要继续发布新的热更新，只需反复执行pushy bundle命令即可，不需要重新打包。恭喜你，至此为止，你已经完成了植入代码热更新的全部工作。","测试发布与回滚#测试、发布与回滚":"我们强烈建议您先发布一个测试包，再发布一个除了版本号以外均完全相同的正式包。例如，假设我们有一个正式包，版本为1.6.0，那么可以修改版本号重新打包一个1001.6.0，以一个明显不太正常的版本号来标识它是一个测试版本，同时后几位相同，可以表明它和某个正式版本存在关联（内容/依赖一致）。在每次往发布包发起热更新之前，先对测试包1001.6.0进行更新操作，基本测试通过之后，再在网页后台上将热更包重新绑定到正式包1.6.0上。如果在测试包中发现了重大问题，你就可以先进行修复，更新测试确认通过后再部署到正式线上环境。这样，可以最大程度的避免发生线上事故。万一确实发生线上事故需要回滚的话，首先利用版本控制系统回滚代码到正常的状态，然后重新生成热更包并推送即可。"}},"/":{"title":"Index","data":{}},"/pricing":{"title":"价格","data":{}}}