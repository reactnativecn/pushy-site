[{"title":"API Token","content":"API Token 是一种用于在 CI/CD 流程或自动化脚本中调用 [Pushy API]() 的认证方式。相比直接使用账号密码，API Token 更加安全且便于管理。\n\n## 使用场景\n\n- **持续集成/持续部署 (CI/CD)**：在 GitHub Actions、GitLab CI、Jenkins 等平台中自动发布热更新\n- **自动化脚本**：编写脚本批量管理应用、版本或原生包\n- **第三方工具集成**：将 Pushy 与其他开发工具集成\n\n## 创建 API Token\n\n1. 登录 [Pushy 管理后台]()\n2. 在左侧菜单中点击「API Token」\n3. 点击「创建 Token」按钮\n4. 填写 Token 名称（如：CI/CD Pipeline）\n5. 选择所需权限\n6. 可选设置过期时间\n7. 点击创建后，**立即复制并安全保存 Token**\n\n:::warning\nToken 只会在创建时显示一次，之后无法再次查看。请务必在创建后立即复制保存！\n:::\n\n## 权限说明\n\n| 权限              | 说明                 |\n| --------------- | ------------------ |\n| **读取 (read)**   | 查看应用、版本、原生包信息      |\n| **写入 (write)**  | 创建和更新应用、发布版本、上传原生包 |\n| **删除 (delete)** | 删除应用、版本、原生包        |\n\n:::info\n创建 Token 时至少需要选择一个权限。根据实际需求选择最小必要权限是最佳实践。\n:::\n\n## 使用 Token 调用 API\n\n在调用 Pushy API 时，将 Token 添加到请求头中：\n\n```bash\ncurl -X GET \"https://update.reactnative.cn/api/app/list\" \\\n  -H \"x-api-token: YOUR_API_TOKEN\"\n```\n\n### 在命令行工具中使用\n\n如果使用 `react-native-update-cli` 命令行工具（需 v2.7.0+），可以通过环境变量设置 Token：\n\n```bash\nexport PUSHY_API_TOKEN=your_api_token_here\npushy bundle --platform android\n```\n\n### 在 CI/CD 中使用\n\n以 GitHub Actions 为例：\n\n```yaml\n# .github/workflows/publish.yml\nname: Publish Hot Update\n\non:\n  push:\n    branches: [main]\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      \n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '18'\n          \n      - name: Install dependencies\n        run: npm install && npm i -g react-native-update-cli\n        \n      - name: Publish update\n        env:\n          PUSHY_API_TOKEN: ${{ secrets.PUSHY_API_TOKEN }}\n        run: pushy bundle --platform android\n```\n\n:::tip\n在 CI/CD 环境中，建议将 Token 存储在密钥管理中（如 GitHub Secrets），而不是直接写入代码。\n:::\n\n## 管理 Token\n\n### 查看 Token 列表\n\n在「API Token」页面可以看到所有已创建的 Token，包括：\n\n- Token 名称\n- 权限\n- 过期时间\n- 最后使用时间\n- 状态（正常/已过期/已撤销）\n\n### 撤销 Token\n\n如果 Token 泄露或不再需要，可以随时撤销：\n\n1. 在 Token 列表中找到目标 Token\n2. 点击「撤销」按钮\n3. 确认撤销\n\n:::warning\nToken 撤销后立即生效，使用该 Token 的所有请求将被拒绝。请确保在撤销前更新相关的 CI/CD 配置。\n:::\n\n## 安全建议\n\n1. **最小权限原则**：只授予 Token 必要的权限\n2. **设置过期时间**：为临时使用的 Token 设置合理的过期时间\n3. **定期轮换**：定期撤销旧 Token 并创建新 Token\n4. **安全存储**：不要将 Token 提交到代码仓库，使用环境变量或密钥管理工具\n5. **监控使用**：定期检查 Token 的最后使用时间，及时清理不再使用的 Token\n\n## 限制\n\n- 每个用户最多可创建 **10 个** API Token\n- 如需创建更多，请先撤销不再使用的 Token\n","routePath":"/docs/api-token","lang":"en","toc":[{"id":"使用场景","text":"使用场景","depth":2,"charIndex":88},{"id":"创建-api-token","text":"创建 API Token","depth":2,"charIndex":231},{"id":"权限说明","text":"权限说明","depth":2,"charIndex":452},{"id":"使用-token-调用-api","text":"使用 Token 调用 API","depth":2,"charIndex":722},{"id":"在命令行工具中使用","text":"在命令行工具中使用","depth":3,"charIndex":883},{"id":"在-cicd-中使用","text":"在 CI/CD 中使用","depth":3,"charIndex":1053},{"id":"管理-token","text":"管理 Token","depth":2,"charIndex":1733},{"id":"查看-token-列表","text":"查看 Token 列表","depth":3,"charIndex":1746},{"id":"撤销-token","text":"撤销 Token","depth":3,"charIndex":1849},{"id":"安全建议","text":"安全建议","depth":2,"charIndex":2008},{"id":"限制","text":"限制","depth":2,"charIndex":2211}],"frontmatter":{"order":12,"title":"API Token","type":"开发指南"},"version":"","description":"API Token 是一种用于在 CI/CD 流程或自动化脚本中调用 Pushy API 的认证方式。相比直接使用账号密码，API Token 更加安全且便于管理。"},{"title":"API参考","content":"### JavaScript 方法\n\n#### new Pushy(options: PushyOptions)\n\n创建 Pushy 热更新服务实例，其构造参数如下：\n\n```ts\ninterface PushyOptions {\n  // 必填，通过pushy createApp或selectApp命令，或在网页管理端获取\n  appKey: string;\n\n  // 自定义日志输出，也可用于上报统计数据\n  logger?: ({ type, data }: { type: EventType; data: EventData }) => void;\n\n  // 触发自动检查更新的策略\n  checkStrategy?:\n    | \"onAppStart\" // 仅在app启动时\n    | \"onAppResume\" // 仅在app从后台切换到前台时\n    | \"both\"; // 默认值，同时包含前两个场景\n    | null; // 不自动检查更新，必须手动调用checkUpdate方法，此选项需 v10.4.2+ 版本\n\n  // 自动下载和应用更新的策略\n  updateStrategy?:\n    | \"alwaysAlert\" // 调试环境（__DEV__）默认值，使用系统默认的alert页面提示热更且会在有报错时弹出提示\n    | \"alertUpdateAndIgnoreError\" // 生产环境默认值，在有热更时使用系统默认的alert页面提示热更，但不弹出任何报错提示\n    | \"silentAndNow\" // 自动静默下载并立刻应用热更\n    | \"silentAndLater\"; // 自动静默下载，但仅在用户退出app后重启时应用更新\n    | null; // 不自动下载和应用更新，如需自定义热更界面请选择此项\n\n  // 是否在热更重启后自动标记为成功，默认为true\n  // 一般情况下不建议手动标记\n  autoMarkSuccess?: boolean;\n\n  // 是否在若干ms后自动清除最后的报错，默认为不清除\n  dismissErrorAfter?: number;\n\n  // 是否在开发环境中检查热更，默认为false。如需在开发环境中调试热更，请打开此选项。\n  // 但即便打开此选项，也仅能检查、下载热更，并不能实际应用热更。实际应用热更必须在release包中进行。\n  // 此选项需 v10.4.2+ 版本\n  debug?: boolean;\n\n  // 是否在调用 checkUpdate 和 downloadUpdate 时抛出错误，默认为不抛出错误，通过 lastError 获取错误信息\n  // 启用后可以使用 try catch 语句 捕获错误，同时 lastError 也仍然可用\n  // try {\n  //   await checkUpdate();\n  // } catch (e) {\n  //   console.error(e);\n  // }\n  // 此选项需 v10.15.2+ 版本\n  throwError?: boolean;\n\n  // 在检查更新前执行，返回 false 则取消检查更新\n  // 此选项需 v10.12.0+ 版本\n  beforeCheckUpdate?: () => Promise<boolean>;\n\n  // 在下载更新前执行，返回 false 则取消下载更新，可以配合自定义的 metaInfo 做一些条件控制\n  // 此选项需 v10.12.0+ 版本\n  beforeDownloadUpdate?: (info: UpdateInfo) => Promise<boolean>;\n\n  // 在下载更新后执行，返回 false 则取消内置策略进一步执行，可以配合自定义的 metaInfo 做一些条件控制\n  // 此选项需 v10.27.0+ 版本\n  afterDownloadUpdate?: (info: UpdateInfo) => Promise<boolean>;\n\n  // 在原生包过期时执行，返回 false 则取消内置策略进一步执行，可以配合自定义的 metaInfo 做一些条件控制\n  // 此选项需 v10.28.2+ 版本\n  onPackageExpired?: (info: UpdateInfo) => Promise<boolean>;\n}\n\n// 日志事件类型\ntype EventType =\n  // 更新失败，重启后发生回滚\n  | \"rollback\"\n  // 检查更新时报错\n  | \"errorChecking\"\n  // 正在发起检查\n  | \"checking\"\n  // 正在下载更新\n  | \"downloading\"\n  // 已下载更新\n  | \"downloadSuccess\"\n  // 更新失败\n  | \"errorUpdate\"\n  // 更新成功\n  | \"markSuccess\"\n  // 下载apk\n  | \"downloadingApk\"\n  // 下载apk前申请存储权限被用户拒绝\n  | \"rejectStoragePermission\"\n  // 下载apk前申请存储权限发生错误\n  | \"errorStoragePermission\"\n  // 下载apk时发生错误\n  | \"errorDownloadAndInstallApk\";\n\n// 日志事件数据\ninterface EventData {\n  // 当前已完成的热更hash值，如尚未热更则为空字符串\n  currentVersion: string;\n  // 客户端版本信息\n  cInfo: {\n    rnu: string; // 当前 react-native-update 版本\n    rn: string; // 当前 react-native 版本\n    os: string; // 当前操作系统及版本\n    uuid: string; // 用户标识符\n  };\n  // 客户端原生版本号\n  packageVersion: string;\n  // 编译时间戳\n  buildTime: number;\n  // 报错相关的信息\n  message?: string;\n  // 发生回滚的版本hash值\n  rolledBackVersion?: string;\n  // 更新失败的新版本hash值\n  newVersion?: string;\n  // 其他一些数据\n  [key: string]: any;\n}\n```\n\n#### useUpdate()\n\n热更相关的工具函数。此方法也可使用别名 `usePushy` 引入。\n\n:::info\n注意，在使用 `<UpdateProvider>` 的当前组件（一般是根组件）中无法直接调用`useUpdate`，只有当前组件的子组件才能调用。\n:::\n\n```js\nconst {\n  checkUpdate,\n  switchVersion,\n  switchVersionLater,\n  markSuccess,\n  dismissError,\n  downloadUpdate,\n  downloadAndInstallApk,\n  getCurrentVersionInfo,\n  currentVersionInfo,\n  parseTestQrCode,\n  currentHash,\n  packageVersion,\n  client,\n  progress,\n  updateInfo,\n  lastError,\n  restartApp,\n} = useUpdate();\n```\n\n其类型定义和功能如下：\n\n```ts\ninterface UpdateContext {\n  // 检查更新（注意在 v10.26.0 版本之前，`checkUpdate`方法本身没有返回值，只能从`useUpdate()`返回的`updateInfo`中获取）\n  // 我们也仍然推荐优先从`useUpdate()`中获取`updateInfo`\n  checkUpdate: () => Promise<void | UpdateInfo>;\n  // 下载热更完成后调用，立即重启切换新版本\n  switchVersion: () => void;\n  // 下载热更完成后调用，用户手动重启app后切换新版本（静默更新）\n  switchVersionLater: () => void;\n  // 热更完成重启后，手动标记热更完成\n  markSuccess: () => void;\n  // 清除最后的报错状态\n  dismissError: () => void;\n  // 下载热更, v10.16.0+ 版本返回值为`boolean`，表示是否下载成功\n  downloadUpdate: () => Promise<boolean | void>;\n  // 下载并安装apk\n  downloadAndInstallApk: (url: string) => Promise<void>;\n  // 异步获取当前已热更版本的信息，v10.31.2 版本后用 `currentVersionInfo` 代替\n  getCurrentVersionInfo: () => Promise<{\n    name?: string;\n    description?: string;\n    metaInfo?: string;\n  }>;\n  // 当前已热更版本的信息，需 v10.31.2+ 版本\n  currentVersionInfo: {\n    name?: string;\n    description?: string;\n    metaInfo?: string;\n  };\n  // 解析测试二维码，此方法需 v10.11.2+ 版本\n  parseTestQrCode: (qrCode: string) => void;\n  // 当前的版本hash\n  currentHash: string;\n  // 当前的原生版本号\n  packageVersion: string;\n  // 当前的pushy热更服务实例\n  client?: Pushy;\n  // 下载开始后的进度数据\n  progress?: {\n    hash: string;\n    // 已下载的字节数\n    received: number;\n    // 待下载的总字节数\n    total: number;\n  };\n  // 热更相关信息\n  updateInfo?: {\n    // 已是最新版本，无需热更\n    upToDate?: true;\n    // 当前原生版本已过期，需要下载新的原生版本\n    expired?: true;\n    // 在pushy网页管理端设置的原生版本下载地址\n    downloadUrl?: string;\n    // 是否存在新的热更\n    update?: true;\n    // 新热更的版本名称\n    name?: string;\n    // 新热更的hash值\n    hash?: string;\n    // 新热更的更新说明\n    description?: string;\n    // 新热更携带的额外元数据\n    metaInfo?: string;\n    // 当前热更是否已暂停\n    paused?:\n      | \"app\" // 当前应用所有原生版本暂停\n      | \"package\" // 仅当前原生版本暂停\n      | \"quota\"; // 因检查次数超限而暂停\n    // 其他信息\n    message?: string;\n  };\n  // 检查、下载、应用热更等过程中的最近一次报错\n  lastError?: Error;\n}\n```\n\n***\n\n#### async function checkUpdate()\n\n触发更新检查，返回`updateInfo`（注意在 v10.26.0 版本之前，`checkUpdate`方法本身没有返回值，只能从`useUpdate()`返回的`updateInfo`中获取，且我们仍然推荐优先使用`useUpdate()`来获取），返回值有三种情形：\n\n1. `{expired: true}`：该应用原生包已过期（三种情况：1. 主动设置为过期状态，2. 主动删除，3. 从未上传），需要引导用户下载或跳转到应用市场(需要在网页管理端设置中填写`downloadUrl`)。如需在应用内执行 apk 更新，还需配置[安装权限]()。\n\n```js\n{\n    expired: true,\n    downloadUrl: 'http://appstore/downloadUrl',\n}\n```\n\n2. `{upToDate: true}`：当前已经更新到最新，无需进行更新。\n\n3. `{update: true}`：当前有新版本可以更新。`name`、`description`字段可以用于展示给用户版本号，更新内容等信息，而`metaInfo`字段则可以根据你的需求自定义一些标记(如是否静默更新、是否强制更新等等，自己根据标记的属性做一些条件流程控制)，具体用法可参考[场景实践]()。另外还有几个字段，包含了热更新文件的下载地址，\n\n```js\n{\n    update: true,\n    name: '1.0.3-rc',\n    hash: 'hash',\n    description: '添加聊天功能\\n修复商城页面BUG',\n    metaInfo: '{\"silent\":true}',\n    pdiffUrl: 'http://update-packages.reactnative.cn/hash',\n    diffUrl: 'http://update-packages.reactnative.cn/hash',\n}\n```\n\n***\n\n#### async function downloadUpdate()\n\n下载热更包。仅当`update:true`时实际进行下载。会更新`progress`数据。v10.16.0+ 版本返回值为`boolean`，表示是否下载成功。\n\n***\n\n#### async function downloadAndInstallApk(url)\n\n下载更新的 apk 包并直接安装。`url`必须为可直接下载到 apk 文件的地址。\n\n由于系统安全限制等各种外部因素，此功能并不能保证一定正常调用。在应用当前运行周期内，如果下载或者安装失败，则再次调用时不会重试，只会静默失败。\n\n注意要使用这个功能还需要在`AndroidManifest.xml`中手动添加安装权限，如果需要考虑 Android 7.0 以下的客户，则还需要添加外部存储权限。\n\n```xml\n<uses-permission android:name=\"android.permission.REQUEST_INSTALL_PACKAGES\" />\n\n<!-- 如果需要考虑Android 7.0以下的客户，则还需要添加外部存储权限 -->\n<uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n```\n\n注意某些应用市场可能会因为上述权限拒绝应用上架。去掉上述两个权限并不影响热更新功能。\n\n***\n\n#### function markSuccess()\n\n**一般情况下请勿手动调用此函数**。调用此函数作为更新成功的标记（否则下次启动会默认失败自动回滚）。\n\n***\n\n#### async function getCurrentVersionInfo()\n\n获取当前已热更版本的信息（如尚未热更过则返回空对象）。v10.31.2 版本之后可以直接用 `currentVersionInfo` 代替。\n\n返回值示例：\n\n```js\n{\n    name: '1.0.3-rc',\n    description: '添加聊天功能\\n修复商城页面BUG',\n    metaInfo: '{\"silent\":true}',\n}\n```\n\n***\n\n#### function restartApp()\n\n立即重启应用。v10.28.2+ 版本可用。\n\n***\n\n#### function switchVersion()\n\n立即重启应用，并加载已经下载完毕的版本。\n\n> 注意!不可依赖`progress`来判断下载完成，必须要在`await downloadUpdate()`之后再调用此方法。\n\n***\n\n#### function switchVersionLater()\n\n在下一次启动应用的时候加载已经下载完毕的版本。\n\n> 注意!不可依赖`progress`来判断下载完成，必须要在`await downloadUpdate()`之后再调用此方法。\n\n***\n\n#### function parseTestQrCode(qrCode: string)\n\n解析测试二维码，一般用于给 QA 人员测试热更新。如果在应用中已有扫码功能，则可以在应用中扫描 pushy 后台的测试二维码来测试任意版本的热更包。\n注意如果你使用自定义的(更新策略（updateStrategy）)\\[[https://pushy.reactnative.cn/docs/integration#updatestrategy%E6%9B%B4%E6%96%B0%E5%BA%94%E7%94%A8%E7%AD%96%E7%95%A5\\]，请务必从]() `useUpdate()` 中获取 `updateInfo` ，而不要依赖 checkUpdate 方法的返回值，否则扫码不会有后续动作。\n\n注意使用此方法，上述界面中的\"使用 Deep Link\"选项 <u><b>请不要</b></u> 勾选。\n\n代码示例：\n\n```js\n<Camera\n  onReadCode={({ nativeEvent: { codeStringValue } }) => {\n    // 识别到二维码后先关闭相机\n    setShowCamera(false);\n    // 先解析是否是pushy的测试二维码\n    if (parseTestQrCode(codeStringValue)) {\n      // 如果是pushy的测试二维码，则不再做其他业务扫码逻辑\n      return;\n    }\n    // 如果不是，继续处理其他业务扫码逻辑\n  }}\n/>\n```\n\n***\n\n### Android 方法\n\n#### UpdateContext.setCustomInstanceManager(ReactInstanceManager instanceManager)\n\n如果是集成/混编 Android 方案，则可以使用此方法传入你自行创建的 ReactInstanceManager。自`v5.5.8`版本起可用。\n\n示例：\n\n```java\nimport cn.reactnative.modules.update.UpdateContext\n\nmReactInstanceManager = ReactInstanceManager.builder()\n                // ...各种setter，但注意不要调用setBundleAssetName\n                .setJSBundleFile(UpdateContext.getBundleUrl(mContext, \"assets://index.android.bundle\"))\n                .build();\nUpdateContext.setCustomInstanceManager(mReactInstanceManager);\n```\n","routePath":"/docs/api","lang":"en","toc":[{"id":"javascript-方法","text":"JavaScript 方法","depth":3,"charIndex":0},{"id":"new-pushyoptions-pushyoptions","text":"new Pushy(options: PushyOptions)","depth":4,"charIndex":19},{"id":"useupdate","text":"useUpdate()","depth":4,"charIndex":2814},{"id":"async-function-checkupdate","text":"async function checkUpdate()","depth":4,"charIndex":5092},{"id":"async-function-downloadupdate","text":"async function downloadUpdate()","depth":4,"charIndex":5980},{"id":"async-function-downloadandinstallapkurl","text":"async function downloadAndInstallApk(url)","depth":4,"charIndex":6105},{"id":"function-marksuccess","text":"function markSuccess()","depth":4,"charIndex":6617},{"id":"async-function-getcurrentversioninfo","text":"async function getCurrentVersionInfo()","depth":4,"charIndex":6704},{"id":"function-restartapp","text":"function restartApp()","depth":4,"charIndex":6942},{"id":"function-switchversion","text":"function switchVersion()","depth":4,"charIndex":6999},{"id":"function-switchversionlater","text":"function switchVersionLater()","depth":4,"charIndex":7123},{"id":"function-parsetestqrcodeqrcode-string","text":"function parseTestQrCode(qrCode: string)","depth":4,"charIndex":7255},{"id":"android-方法","text":"Android 方法","depth":3,"charIndex":7957},{"id":"updatecontextsetcustominstancemanagerreactinstancemanager-instancemanager","text":"UpdateContext.setCustomInstanceManager(ReactInstanceManager instanceManager)","depth":4,"charIndex":7973}],"frontmatter":{"order":11,"title":"API参考","type":"开发指南"},"version":""},{"title":"场景实践","content":"#### 优化原生和热更包体积\n\n##### iOS 原生包优化(ipa)\n\n对于同一份 archive（其版本号、编译时间和内置 bundle 已固定，不会受导出方式所影响），可以用不同选项多次导出 ipa，选择其中最小的上传到 pushy 服务器作为热更基准包。\n\n##### Android 原生包优化(apk)\n\napk 的优化主要考虑两个方向：\n\n- [启用 proguard 压缩混淆源码]()。但这一步可能导致一些使用反射的代码运行时报错，启用后需要充分测试每个页面和功能，以及需要阅读一些第三方关于 proguard 的特别设置说明。\n- [分开编译不同的 cpu 架构]()。找到`android/app/build.gradle`中的 cpu 架构部分，如下所示启用`enable`选项：\n\n```diff\nsplits {\n    abi {\n        reset()\n-       enable enableSeparateBuildPerCPUArchitecture\n+       enable true        // 启用单独的 cpu 架构编译\n        universalApk false  // If true, also generate a universal APK\n    }\n}\n```\n\n如此一来会在编译目录中输出多个 apk 文件，分发和上传到热更新服务时只需要使用`app-arm64-v8a-release.apk`文件，可以大幅减小 apk 的大小。\n\n##### 热更新包优化(ppk)\n\n热更新包的主要内容是 js 包和其所引用的静态资源（主要是图片）。\n\n- js 包成分分析。可以借助一些第三方工具（如[react-native-bundle-visualizer]()）来分析 js 文件中哪些占比较大，是否可以用其他库替换等（如 dayjs 替换 moment，lodash-es 替换 lodash）。\n- 图片优化。\n  - 在保证体验的情况下，使用一些工具对图片进行裁剪压缩。\n  - 如不需要图片的透明像素，可以考虑将 png 格式转为 jpg 格式。\n  - 还可以进一步考虑压缩比更高的图片格式，例如 webp 格式（需要第三方原生插件例如[react-native-webp-format]()），heif 格式（iOS 11 和 Android 10 以上原生支持）等。这里有个图片格式对比可供参考 [https://compare.rokka.io/\\_compare/#heif=40\\&jpeg=80\\&webp=80\\&av1=40\\&width=800]()。\n\n#### 有很多渠道包需要热更，如何操作比较方便？\n\n1. 如果渠道包的`js代码和初始资源`有差别（无论多么细微的差别都会生成不同的 jsbundle），那么只能单独生成 apk，分别上传和绑定。可以考虑写一些脚本自动调用 cli 来执行批量操作。\n2. 如果渠道包的`js代码和初始资源`完全一致，可以考虑使用[Flavor 构建]()，或其他一些动态生成渠道包的方案（比如[腾讯的 VasDolly]()，[美团的 walle]()等），这样所有的渠道包基于同一个基础 apk 生成（因而会有相同的编译时间戳和 jsbundle）。这样可以只用上传一个基础 apk，对此 apk 的热更操作可以对所有渠道包生效。\n3. 如果您是`高级版`、`专业版`或`大客户VIP版`客户，也可以考虑在管理后台的应用设置中启用`忽略编译时间戳`。此选项仅对比版本号，不校验时间戳，可提供更宽容的热更策略，但可能消耗更多流量。\n\n#### 如何支持 aab 格式的原生包？\n\n将 react-native-update-cli 更新到 v2.6.0 以上版本，即可使用 pushy parseAab 和 pushy uploadAab 命令来支持 aab 格式的原生包。\n\n#### 测试与回滚\n\n自 v10.11.2 版本开始，可以使用以下两种快捷扫码方案来测试热更，而无需提前进行绑定：\n\n- 若应用启用了 [DeepLink]() 功能\n\n代码中无需任何改动，只需在上述界面中勾选“使用 Deep Link”，填入您应用的协议名，例如\"pushy://\"，然后使用系统相机或系统内置的扫一扫功能扫码（注意不能使用微信扫码），即可自动调起应用并触发更新。\n\n- 若应用自带扫码功能\n\n请参考 [parseTestQrCode]() 方法的说明。\n\n<details>\n<summary>若您的应用不具有上述两项功能，或 pushy 版本低于 v10.11.2，则可以参考如下测试方式（不推荐）</summary>\n\n先发布一个**测试包**，再发布一个除了版本号以外均完全相同的**正式包**。\n\n例如，假设我们有一个正式包，版本为`1.6.0`，那么可以修改版本号重新打包一个`1001.6.0`，以一个明显不太正常的版本号来标识它是一个测试版本，同时后几位相同，可以表明它和某个正式版本存在关联（内容/依赖一致）。\n\n在每次往发布包发起热更新之前，先对**测试包**`1001.6.0`进行更新操作，基本测试通过之后，再在网页后台上将热更包重新绑定到**正式包**`1.6.0`上。如果在测试包中发现了重大问题，你就可以先进行修复，更新测试确认通过后再部署到正式线上环境。这样，可以最大程度的避免发生线上事故。\n\n</details>\n\n若您用来测试的原生包当前已经有发布的热更版本且更新策略是立即应用，那么和扫码测试之间可能产生策略冲突，比如扫码更新后又立即强制更新到发布版本，对测试带来不便。此时可以考虑在扫码更新之后，利用 beforeCheckUpdate 回调临时禁止更新检查，直到下次启动再恢复。\n\n```js\n\n// isFirstTimeDebug 这个标志位需要 v10.37.0+ 版本，表示当前是扫码热更后的第一次启动\n\n\nconst pushyClient = new Pushy({\n  beforeCheckUpdate: () => {\n    if (isFirstTimeDebug) {\n      // 如果当前是扫码热更后的第一次启动，则跳过热更检查\n      return false;\n    }\n    return true;\n  },\n})\n```\n\n万一确实发生线上事故需要回滚的话，先立即对原生包或者整个应用设置暂停热更，然后更改绑定到之前正常的版本，或者利用版本控制系统回滚代码到正常的状态，然后重新生成热更包并推送。\n\n#### 元信息(Meta Info)的使用\n\n在发布热更新版本时，或者在网页端，你可以编辑版本的元信息。这是一段在检查更新时可以获得的字符串，你可以在其中按你所想的格式（一般建议用[JSON 格式]()）保存一些信息。\n\n比如我们可以在元信息中约定字段标志`silent`，表示需要静默更新。当我们上传热更包填写 metainfo 时，以[JSON 格式]()输入：\n\n```json\n{ \"silent\": true }\n```\n\n> 请注意，我们并不对输入做任何格式校验和约束，请自行校验输入是否正确。\n\n此时在客户端检查更新时，能获取到我们刚刚输入的元信息，但它并不具备任何功能，只是一个字符串而已。所以我们其实需要**预先**在更新流程中加入对应的处理逻辑：\n\n```js\n// 调用 useUpdate() 获取 updateInfo\nif (updateInfo.expired) {\n  // ... 原生包版本过期，下载或跳转下载页面\n} else if (updateInfo.upToDate) {\n  // ... 没有更新，弹提示或忽略\n} else {\n  // 有更新，一般来说我们在这里给用户弹窗提示，让用户选择是否更新\n  // 那么静默更新的本质其实就是不弹窗，直接执行，所以可以在这里加入额外的判断流程\n  // ...\n}\n```\n\n我们在原有的更新流程中加入元信息的读取和判断：\n\n```js\nlet metaInfo = {};\ntry {\n  // 注意 JSON 输入有可能有错误，需要用 try 语句来避免应用被带崩\n  metaInfo = JSON.parse(updateInfo.metaInfo);\n} catch (e) {\n  // 异常处理，忽略或上报？\n}\n\nif (metaInfo.silent) {\n  // 如果热更包携带有 silent 字段，不询问用户，直接执行更新\n  switchVersion();\n} else {\n  // 否则还是走之前的询问流程\n  // Alert.alert('提示', '检查到新的版本.......\n}\n```\n\n又比如，可能某个版本包含一些重要的公告内容，所以还可以在上面插入一个公告字段等等。如何使用元信息，完全取决于您的想象力！\n","routePath":"/docs/bestpractice","lang":"en","toc":[{"id":"优化原生和热更包体积","text":"优化原生和热更包体积","depth":4,"charIndex":0},{"id":"有很多渠道包需要热更如何操作比较方便","text":"有很多渠道包需要热更，如何操作比较方便？","depth":4,"charIndex":1141},{"id":"如何支持-aab-格式的原生包","text":"如何支持 aab 格式的原生包？","depth":4,"charIndex":1551},{"id":"测试与回滚","text":"测试与回滚","depth":4,"charIndex":1673},{"id":"元信息meta-info的使用","text":"元信息(Meta Info)的使用","depth":4,"charIndex":2780}],"frontmatter":{"order":13,"title":"场景实践","type":"开发指南"},"version":""},{"title":"命令行工具（内置）","content":"### 安装\n\n```\n$ npm install -g react-native-update-cli\n```\n\n### 命令\n\n#### pushy bundle\n\n生成热更资源包。会自动探测项目中是否使用了 expo、taro 等框架并自动调用对应的命令行打包。如果探测不准确或使用对应命令行打包时报错，可尝试使用 `--rncli` 参数来指定官方命令行打包。\n\n- platform: ios|android|harmony 对应的平台\n- entryFile: 入口脚本文件\n- intermediaDir: 临时文件输出目录\n- output: 最终 ppk 文件输出路径\n- dev: 是否打包开发版本\n- sourcemap: 是否生成 sourcemap(需 cli 版本 1.11.0+)\n- no-interactive: 不进行交互式提示\n- rncli: 指定使用官方命令行打包 (需 cli 版本 1.40.0+)\n- expo: 指定使用 expo 的命令行打包 (需 cli 版本 1.40.0+)\n- taro: 指定使用 taro 的命令行打包 (需 cli 版本 1.40.0+)\n\n从 v1.44.2 版本开始，新增了以下直接上传发布的参数（等同于打包完成后连续调用 `pushy publish` 命令）：\n\n- name: 指定热更新版本的名字(热更自身的版本号)\n- description: 指定热更新版本的描述信息，可以对用户进行展示\n- metaInfo: 指定热更新版本的元信息，可以用来保存一些额外信息，具体用法可参考[场景实践]()。\n\n从 v1.46.1 版本开始，在传入 `name`， `description`， `metaInfo` 参数的同时，可继续叠加以下参数（等同于在调用`pushy publish` 命令后，再连续调用 `pushy update` 命令）：\n\n- packageId: 要绑定的原生包 ID （多选一）\n- packageVersion: 要绑定的原生包版本名（多选一）\n- minPackageVersion: 要绑定的最低原生包版本，大于等于此版本的将逐个绑定（多选一）\n- maxPackageVersion: 要绑定的最高原生包版本，小于等于此版本的将逐个绑定（多选一）\n- packageVersionRange: 要绑定的原生包版本范围（多选一），范围格式遵循 semver 的语法，可参考 [https://quickref.cnxiaobai.com/docs/semver.html]() 或 [https://devhints.io/semver]()\n\n示例：\n\n```bash\n\npushy bundle --platform android --name \"1.0.0\" --description \"热更新版本 1.0.0\" --metaInfo '{\"key\": \"value\"}' --packageVersionRange \">=1.0 <3.0\"\n```\n\n***\n\n#### pushy parseIpa \\[ipaFile]\n\n解析 ipa 文件并输出一些相关信息，如版本号，编译时间戳等。\n\n***\n\n#### pushy parseApk \\[apkFile]\n\n解析 apk 文件并输出一些相关信息，如版本号，编译时间戳等。\n\n***\n\n#### pushy parseApp \\[appFile]\n\n解析 app 文件并输出一些相关信息，如版本号，编译时间戳等。\n\n***\n\n#### pushy parseAab \\[aabFile]\n\n解析 aab 文件并输出一些相关信息，如版本号，编译时间戳等。\n\n***\n\n#### pushy diff \\[origin]\\[next]\n\n提供两个 ppk 文件，生成从 origin 到 next 版本的差异更新包。\n\n- output: diff 文件输出路径\n\n***\n\n#### pushy diffFromApk \\[apkFile]\\[next]\n\n提供一个 apk 文件和一个 ppk 文件，生成从 apk 文件到 next 版本的差异更新包。\n\n如果使用热更新开放平台，你不需要自己执行此命令。\n\n- output: diff 文件输出路径\n\n***\n\n#### pushy diffFromApp \\[appFile]\\[next]\n\n提供一个 app 文件和一个 ppk 文件，生成从 app 文件到 next 版本的差异更新包。\n\n如果使用热更新开放平台，你不需要自己执行此命令。\n\n- output: diff 文件输出路径\n\n***\n\n#### pushy diffFromIpa \\[ipaFile]\\[next]\n\n提供一个 ipa 文件和一个 ppk 文件，生成从 ipa 文件到 next 版本的差异更新包。\n\n如果使用热更新开放平台，你不需要自己执行此命令。\n\n- output: diff 文件输出路径\n\n***\n\n#### pushy login \\[email]\\[pwd]\n\n登录热更新开放平台。你需要先登录才能使用下面的命令。\n\n***\n\n#### pushy logout\n\n登出并清除本地的登录信息\n\n***\n\n#### pushy me\n\n查看自己是否已经登录，以及昵称等信息。\n\n***\n\n#### pushy createApp\n\n创建应用并立刻绑定到当前工程。这项操作也可以在网页管理端进行。\n\n- platform: ios|android|harmony 对应的平台\n- name: 应用名称\n- downloadUrl: 应用安装包的下载地址\n\n***\n\n#### pushy deleteApp \\[appId]\n\n删除已有应用。所有已创建的应用包、热更新版本都会被同时删除。这项操作也可以在网页管理端进行。\n\n- appId: 要删除的应用 ID\n\n***\n\n#### pushy apps\n\n查看当前已创建的全部应用。这项操作也可以在网页管理端进行。\n\n- platform: ios|android|harmony 对应的平台\n\n***\n\n#### pushy selectApp \\[appId]\n\n绑定应用到当前工程。\n\n- platform: ios|android|harmony 对应的平台\n\n***\n\n#### pushy uploadIpa \\[ipaFile]\n\n上传 ipa 文件到开放平台。（cli 需 1.24.0 +）\n\n***\n\n#### pushy uploadApk \\[apkFile]\n\n上传 apk 文件到开放平台。（cli 需 1.24.0 +）\n\n***\n\n#### pushy uploadApp \\[appFile]\n\n上传 app 文件到开放平台。（cli 需 1.24.0 +）\n\n***\n\n#### pushy uploadAab \\[aabFile]\n\n上传 aab 文件到开放平台。（cli 需 2.6.0 +）\n\n***\n\n#### pushy extractApk \\[aabFile]\n\n从 aab 文件中提取 apk 文件。备注（cli 需 2.6.0 +）\n\n***\n\n#### pushy packages\n\n查看已经上传的原生包。这项操作也可以在网页管理端进行。\n\n- platform: ios|android|harmony 对应的平台\n\n***\n\n#### pushy deletePackage\n\n删除已经上传的原生包。\n\n- appId: 要删除的原生包所属的应用 ID\n- packageId: 要删除的原生包 ID\n\n***\n\n#### pushy publish \\[ppkFile]\n\n发布新的热更新版本（ppk 文件）。\n\n- platform: ios|android|harmony 对应的平台\n- name: 当前热更新版本的名字(版本号)\n- description: 当前热更新版本的描述信息，可以对用户进行展示\n- metaInfo: 当前热更新版本的元信息，可以用来保存一些额外信息，具体用法可参考[场景实践]()。\n\n从 v1.46.1 版本开始，支持以下参数（等同于在 调用`pushy publish` 命令后，再连续调用 `pushy update` 命令）：\n\n- packageId: 要绑定的原生包 ID （多选一）\n- packageVersion: 要绑定的原生包版本名（多选一）\n- minPackageVersion: 要绑定的最低原生包版本，大于等于此版本的将逐个绑定（多选一）\n- maxPackageVersion: 要绑定的最高原生包版本，小于等于此版本的将逐个绑定（多选一）\n- packageVersionRange: 要绑定的原生包版本范围（多选一），范围格式遵循 semver 的语法，可参考 [https://quickref.cnxiaobai.com/docs/semver.html]() 或 [https://devhints.io/semver]()\n\n示例：\n\n```bash\n\npushy publish .pushy/output/android.1750423283653.ppk --platform android --name \"1.0.0\" --description \"热更新版本 1.0.0\" --metaInfo '{\"key\": \"value\"}' --packageVersionRange \">=1.0 <3.0\"\n```\n\n***\n\n#### pushy versions\n\n分页列举可用的版本。这项操作也可以在网页管理端进行。\n\n- platform: ios|android|harmony 对应的平台\n\n***\n\n#### pushy deleteVersion\n\n删除已经发布的热更新版本。\n\n- appId: 要删除的热更新版本所属的应用 ID\n- versionId: 要删除的热更新版本 ID\n\n***\n\n#### pushy update\n\n为一个原生包版本绑定发布一个热更新版本。这项操作也可以在网页管理端进行。以下参数中`packageId`，`packageVersion`，`minPackageVersion`，`maxPackageVersion`和`packageVersionRange`中多选一即可。\n\ncli 2.4.0 版本开始可以同时绑定一个全量和一个灰度版本。2.4.0 之前全量和灰度版本会互相覆盖，后设置的生效。\n\n- platform: ios|android|harmony 对应的平台\n- versionId: 要绑定的热更新版本 ID\n- rollout: 灰度发布范围（整数取值 1 - 100，对应 1% - 100% 终端设备覆盖率），默认为 100（需 cli 版本 1.31.0+）\n- dryRun: 是否只进行预览，不进行实际绑定（需 cli 版本 1.45.4+）\n- packageId: 要绑定的原生包 ID （多选一）\n- packageVersion: 要绑定的原生包版本名（多选一，需 cli 版本 1.7.2+）\n- minPackageVersion: 要绑定的最低原生包版本，大于等于此版本的将逐个绑定（多选一，需 cli 版本 1.27.0+）\n- maxPackageVersion: 要绑定的最高原生包版本，小于等于此版本的将逐个绑定（多选一，需 cli 版本 1.27.0+）\n- packageVersionRange: 要绑定的原生包版本范围（多选一，需 cli 版本 1.45.4+），范围格式遵循 semver 的语法，可参考 [https://quickref.cnxiaobai.com/docs/semver.html]() 或 [https://devhints.io/semver]()\n\n示例：\n\n```bash\n❯ pushy update --versionId 211343 --platform android --packageVersionRange \">=1.0 <3.0\" --dryRun\nreact-native-update-cli: 1.45.4 （最新：1.45.4）\nreact-native-update: 10.28.11 （最新：10.28.11）\n以下是 dry-run 模拟运行结果，不会实际执行任何操作：\n已将热更包 211343 绑定到原生版本 1.28.1 (id: 75219)\n已将热更包 211343 绑定到原生版本 1.28 (id: 75184)\n已将热更包 211343 绑定到原生版本 1.5 (id: 73396)\n已将热更包 211343 绑定到原生版本 2.0 (id: 68219)\n已将热更包 211343 绑定到原生版本 1.0 (id: 68158)\n操作完成，共已绑定 5 个原生版本\n```\n","routePath":"/docs/cli","lang":"en","toc":[{"id":"安装","text":"安装","depth":3,"charIndex":0},{"id":"命令","text":"命令","depth":3,"charIndex":58},{"id":"pushy-bundle","text":"pushy bundle","depth":4,"charIndex":66},{"id":"pushy-parseipa-ipafile","text":"pushy parseIpa [ipaFile]","depth":4,"charIndex":-1},{"id":"pushy-parseapk-apkfile","text":"pushy parseApk [apkFile]","depth":4,"charIndex":-1},{"id":"pushy-parseapp-appfile","text":"pushy parseApp [appFile]","depth":4,"charIndex":-1},{"id":"pushy-parseaab-aabfile","text":"pushy parseAab [aabFile]","depth":4,"charIndex":-1},{"id":"pushy-diff-originnext","text":"pushy diff [origin][next]","depth":4,"charIndex":-1},{"id":"pushy-difffromapk-apkfilenext","text":"pushy diffFromApk [apkFile][next]","depth":4,"charIndex":-1},{"id":"pushy-difffromapp-appfilenext","text":"pushy diffFromApp [appFile][next]","depth":4,"charIndex":-1},{"id":"pushy-difffromipa-ipafilenext","text":"pushy diffFromIpa [ipaFile][next]","depth":4,"charIndex":-1},{"id":"pushy-login-emailpwd","text":"pushy login [email][pwd]","depth":4,"charIndex":-1},{"id":"pushy-logout","text":"pushy logout","depth":4,"charIndex":2188},{"id":"pushy-me","text":"pushy me","depth":4,"charIndex":2226},{"id":"pushy-createapp","text":"pushy createApp","depth":4,"charIndex":2267},{"id":"pushy-deleteapp-appid","text":"pushy deleteApp [appId]","depth":4,"charIndex":-1},{"id":"pushy-apps","text":"pushy apps","depth":4,"charIndex":2509},{"id":"pushy-selectapp-appid","text":"pushy selectApp [appId]","depth":4,"charIndex":-1},{"id":"pushy-uploadipa-ipafile","text":"pushy uploadIpa [ipaFile]","depth":4,"charIndex":-1},{"id":"pushy-uploadapk-apkfile","text":"pushy uploadApk [apkFile]","depth":4,"charIndex":-1},{"id":"pushy-uploadapp-appfile","text":"pushy uploadApp [appFile]","depth":4,"charIndex":-1},{"id":"pushy-uploadaab-aabfile","text":"pushy uploadAab [aabFile]","depth":4,"charIndex":-1},{"id":"pushy-extractapk-aabfile","text":"pushy extractApk [aabFile]","depth":4,"charIndex":-1},{"id":"pushy-packages","text":"pushy packages","depth":4,"charIndex":3048},{"id":"pushy-deletepackage","text":"pushy deletePackage","depth":4,"charIndex":3142},{"id":"pushy-publish-ppkfile","text":"pushy publish [ppkFile]","depth":4,"charIndex":-1},{"id":"pushy-versions","text":"pushy versions","depth":4,"charIndex":4039},{"id":"pushy-deleteversion","text":"pushy deleteVersion","depth":4,"charIndex":4132},{"id":"pushy-update","text":"pushy update","depth":4,"charIndex":4232}],"frontmatter":{"order":12,"title":"命令行工具（内置）","type":"开发指南"},"version":""},{"title":"命令行工具（自定义模块）","content":"## 模块化功能 (Module System)\n\n从 v2.0.0 版本开始，CLI 支持模块化扩展，允许开发者自定义命令和工作流。\n\n### 核心概念\n\n- **CLI Module**: 包含自定义命令和工作流的模块\n- **Command**: 单个可执行的命令\n- **Workflow**: 由多个步骤组成的复杂工作流\n- **Module Manager**: 管理模块注册和执行的核心组件\n\n### 模块注册\n\n```typescript\n\n\n\n// 注册自定义模块\nmoduleManager.registerModule(myCustomModule);\n```\n\n### 创建自定义模块\n\n```typescript\n\n\nexport const myCustomModule: CLIModule = {\n  name: 'my-module',\n  version: '1.0.0',\n  commands: [\n    {\n      name: 'my-command',\n      description: '我的自定义命令',\n      handler: async (context: CommandContext): Promise<CommandResult> => {\n        // 命令执行逻辑\n        return { success: true, data: 'Hello from custom command!' };\n      },\n      options: {\n        flag: {\n          hasValue: true,\n          description: '自定义参数'\n        }\n      }\n    }\n  ],\n  workflows: [\n    {\n      name: 'my-workflow',\n      description: '我的自定义工作流',\n      steps: [\n        {\n          name: 'step1',\n          description: '第一步',\n          execute: async (context: CommandContext) => {\n            console.log('执行第一步...');\n            return { step1Result: 'completed' };\n          }\n        },\n        {\n          name: 'step2',\n          description: '第二步',\n          execute: async (context: CommandContext, previousResult: any) => {\n            console.log('执行第二步，前一步结果:', previousResult);\n            return { ...previousResult, step2Result: 'completed' };\n          }\n        }\n      ]\n    }\n  ],\n  init: (provider) => {\n    console.log('模块初始化完成');\n  }\n};\n```\n\n### 查看已注册模块命令\n\n```bash\n# 查看所有可用模块命令\npushy list\n```\n\n***\n\n## 工作流系统 (Workflow System)\n\n工作流是由多个步骤组成的复杂任务执行流程，支持条件执行、错误处理和结果传递。\n\n### 内置工作流\n\n#### 1. 用户认证工作流\n\n##### pushy auth-check\n\n检查用户认证状态\n\n```bash\npushy workflow auth-check\n```\n\n##### pushy login-flow\n\n完整的用户登录流程\n\n```bash\npushy workflow login-flow\n```\n\n#### 2. 应用管理工作流\n\n##### pushy workflow multi-platform-app-management\n\n跨平台应用统一管理\n\n```bash\npushy workflow multi-platform-app-management\n```\n\n##### pushy workflow incremental-build\n\n增量构建工作流，生成差异更新包\n\n```bash\npushy workflow incremental-build\n```\n\n### 工作流管理命令\n\n列出所有可用工作流\n\n```bash\npushy list\n```\n\n##### pushy workflow\n\n执行指定工作流\n\n```bash\npushy workflow <workflowName>\n```\n\n##### pushy list\n\n列出所有已注册的模块\n\n```bash\npushy list\n```\n\n### 工作流特性\n\n1. **步骤化执行**: 工作流由多个步骤组成，按顺序执行\n2. **结果传递**: 每个步骤的结果可以传递给下一个步骤\n3. **条件执行**: 支持根据条件决定是否执行某个步骤\n4. **错误处理**: 内置错误处理和回滚机制\n5. **进度反馈**: 实时显示执行进度和状态\n6. **参数验证**: 执行前自动验证必需参数\n\n***\n\n## 示例项目\n\n在项目的 `example/` 目录中提供了完整的模块和工作流使用示例：\n\n- `example/modules/` - 自定义模块示例\n- `example/workflows/` - 自定义工作流示例\n- `example/scripts/` - 使用脚本示例\n\n运行示例：\n\n```bash\n# 模块注册和执行示例\nnpx ts-node example/scripts/register-modules.ts\n\n# 工作流演示\nnpx ts-node example/scripts/workflow-demo.ts\n\n# 增强工作流演示\nnpx ts-node example/scripts/enhanced-workflow-demo.ts\n```\n","routePath":"/docs/cli_module","lang":"en","toc":[{"id":"模块化功能-module-system","text":"模块化功能 (Module System)","depth":2,"charIndex":0},{"id":"核心概念","text":"核心概念","depth":3,"charIndex":69},{"id":"模块注册","text":"模块注册","depth":3,"charIndex":204},{"id":"创建自定义模块","text":"创建自定义模块","depth":3,"charIndex":293},{"id":"查看已注册模块命令","text":"查看已注册模块命令","depth":3,"charIndex":1470},{"id":"工作流系统-workflow-system","text":"工作流系统 (Workflow System)","depth":2,"charIndex":1527},{"id":"内置工作流","text":"内置工作流","depth":3,"charIndex":1595},{"id":"1-用户认证工作流","text":"1. 用户认证工作流","depth":4,"charIndex":1606},{"id":"2-应用管理工作流","text":"2. 应用管理工作流","depth":4,"charIndex":1770},{"id":"工作流管理命令","text":"工作流管理命令","depth":3,"charIndex":2011},{"id":"工作流特性","text":"工作流特性","depth":3,"charIndex":2187},{"id":"示例项目","text":"示例项目","depth":2,"charIndex":2371}],"frontmatter":{"order":12,"title":"命令行工具（自定义模块）","type":"开发指南"},"version":""},{"title":"常见问题","content":"如果本页面没能回答您的疑问，您可以去[issues 区]()或 QQ 群 729013783 提问，或给我们发[邮件]()。\n\n### 业务问题\n\n#### 热更新究竟能否上架？\n\n您可能听说过各种说法，但大量实践表明，热更新目前能够顺利上架 AppStore 和其他各种应用市场。唯一需要注意的是，在审核期间请不要发布热更新，不要让审核人员看到各种更新相关的提示和弹窗，即可顺利通过。\n\n***\n\n#### 是否可以在海外使用？\n\n可以的，国内外都有高速 CDN 节点。\n\n***\n\n#### 哪些修改可以热更新？哪些不能？\n\n我们把对应用的修改分为两类：\n\n- 不可热更新 —— 原生修改，即所有需要`编译`后才能生效的修改：\n  - 任何在 iOS 或者 Android 目录中的修改、增删。\n  - 任何含有原生代码的第三方组件的更新、修改。\n- 可以热更新 —— 非原生修改，即所有`无需编译`，刷新即可生效的修改：\n\n  - js 代码修改，包括第三方纯 js 组件的更新、修改。\n  - 可以在 js 代码中 require/import 的资源文件，例如图片。\n\n需要注意的是，即便资源文件可以热更新，但这些热更新后的资源文件会以`file://`协议的形式提供访问，某些读取资源文件的第三方可能并不支持`file://`协议。\n\n***\n\n#### 热更新成功完成，但是重启后又回滚了是怎么回事？\n\n可以正常更新，但是重启后回滚，一般有两种可能的情况：\n\n- 没有正确[配置 bundleUrl]()\n- （仅有 v10 以下版本存在此可能性，v10 及更高版本不存在此情况）没有正确[调用 markSuccess]()\n\n如果你确定上述两个步骤都正确无误，请在[issues 区]()给我们留言反馈。\n\n***\n\n#### 热更新报错：“热更新已暂停，原因：编译时间戳与服务器记录不一致。”\n\n当您每次编译产生一个原生包时，其中都会记录一个编译时间戳`buildTime`(可以使用`pushy parseIpa a.ipa`或是`pushy parseApk a.apk`命令来查看)。如果您需要把这个包发给客户并希望使用热更新功能，那么就需要使用 upload 命令来上传到我们的服务器，而服务器端会记录这个包的版本号和编译时间戳以便后续比对记录。\n\n举例来说，假如我已经上传了一个 1.0 版本原生包（`1A包`），但后来由于种种原因我又重新打包了（`1B包`）但没有上传，这两个包有相同的版本号，但会有不同的编译时间戳。此时有几种可能的情况：\n\n1. 我忘记上传过`1A包`，`1B包`没有实质更改且还没有客户安装。此时应当放弃`1B包`，只让客户下载安装`1A包`。\n2. 我忘记上传过`1A包`，又生成了`1B包`且已有客户安装。此时`1A包`客户可以获取热更新，`1B包`客户无法获取热更新。要使两批客户都能获取热更新，要么想办法通知`1B包`客户装回`1A包`，要么重新发布一个`高于1.0`版本的原生包且上传到 pushy 服务器，并删除`1.0`版本的记录，此时`1A包`和`1B包`的客户都会收到版本过期需要下载新版本的通知。\n3. 我知道上传过`1A包`，但我有原生方面的修改需要打了一个新的`1B包`。此时若将`1B包`上传到 pushy 服务器会提示版本验证错误，因为已经存在有相同的`1.0`版本。所以需要首先更改原生版本号再次打包，并`首先`将此新版本上传到服务器，`然后`分发给客户。这样`1.0版本`和`新版本`可以并存且都可以获得热更新。\n\n请谨记，任何时候生成原生包，请 1)先修改原生版本号，2)并上传到 pushy 服务器，才可以正常获得热更新。\n\n:::info\n如果您是`高级版`、`专业版`或`大客户VIP版`客户，也可以考虑在管理后台的应用设置中启用`忽略编译时间戳`。此选项仅对比版本号，不校验时间戳，可提供更宽容的热更策略，但可能消耗更多流量，适合需要管理多个分发渠道的客户。\n:::\n\n***\n\n### 付费问题\n\n#### 我应该选择哪个业务版本呢？\n\n其实完全无需考虑，先从最高配额的`专业版`开始体验（新用户注册验证通过后，将自动获得 7 天`专业版`试用），各个版本的使用流程完全一致！当试用时间到期后，若当前版本的配额不能满足需求，可随时补差价升级到更高配额的版本。升级自动按天数计算差价，绝无额外费用。\n\n目前仅有一项额外的付费专用功能，即`忽略编译时间戳`设置（在管理后台的应用设置中），此选项仅对比版本号，不校验时间戳，可提供更宽容的热更策略，但可能消耗更多流量，适合需要管理多个分发渠道的客户。此功能目前仅支持`高级版`、`专业版`和`大客户VIP版`。\n\n***\n\n#### 我可以试用付费版本先评估一下效果吗？\n\n新用户注册验证通过后，将自动获得 7 天`专业版`试用。如您需要更长的评估时间，可将注册用户名、邮箱、公司（或个人）名称发送至 [hi@charmlot.com]() ，标题注明“pushy 评估试用延长”，我们会为您酌情延长评估时间。\n试用期间只能选择续费专业版或升级到更高版本，如需购买其他版本，请等待试用期过期，或者联系客服去除试用。\n\n***\n\n#### 配额具体如何计算？\n\n配额主要分为 4 种：\n\n1. 可创建的应用数量，注意 iOS 和 Android 版本记做不同的应用。\n2. 原生包数量及大小，不同应用分开计算。原生包指通过`pushy uploadIpa/uploadApk`命令上传到 Pushy 服务器上作为热更新起始版本的完整 apk/ipa 安装包。\n3. 热更包数量及大小，不同应用分开计算。热更包指通过`pushy bundle`所命令生成的 ppk 文件。注意这不是用户实际下载的更新文件，用户下载的是通过比对生成的增量 diff 文件（比 ppk 文件要小得多）。\n4. 每日总热更查询次数，所有应用累加计算。每次用户打开应用时，会向服务器查询是否有新的热更新。这个查询次数会被计入每日总热更查询次数。当日超过限额次数后，接口将不再返回新的热更新信息，直到次日重置。\n\n> 这里有一些对[包大小的优化建议]()可供参考。\n\n以上 2、3 条为账户下每个应用单独计算，第 4 条为账户下所有应用累加计算。具体配额和费用由于运营成本可能会有调整，请以[价格表]()页面为准。已购买的用户在续费前不受调整影响。\n\n***\n\n#### 达到配额后还可以正常使用吗？\n\n当应用、原生包、热更包数量达到配额限制后，您将无法执行相应的新增操作。但用户端仍可正常检查更新，下载已发布的更新。您可选择升级到更高配额，或是通过删除已不再使用的应用、原生包、热更包来使数量降低到配额以内，以便继续执行新增操作。\\\n若原生包、热更包大小超过限额，则会导致上传失败。您可以选择升级到更高配额，或是想办法进行[精简优化]()。\n若当日热更检查次数超过限额，则会导致接口返回空数据。您可以选择升级到更高配额，或是优化热更策略，减少用户端检查更新的频率。\n\n***\n\n#### 我可以单独升级某项配额吗？\n\n如果您需要单独升级某些配额（需要达到高级版以上），请通过邮件 [hi@charmlot.com]() 或 QQ 34731408 与我们联系，我们将根据您的个性化需求为您定制方案和报价。\n\n***\n\n#### 付费业务到期后不续费，现有应用还能否正常使用？\n\n到期后按免费版额度执行。如您现有应用已超出配额，则必须通过删除操作降低到配额以内，方可执行新的操作（如创建应用，上传热更等），但不影响用户获取之前已发布的热更。\n\n***\n\n#### 如何获取付费的专人技术支持？\n\n请将您的用户名和订单截图发送至 [hi@charmlot.com]() ，同时提供您希望的技术联系方式（QQ、微信等），核实后会有技术专员添加您为好友。\n\n***\n\n#### 如何开具发票？\n\n请将具体开票需求发送至 [hi@charmlot.com]() ，并附上注册邮箱和订单截图。我们默认会回复普通电子发票到`注册邮箱`，类目为软件服务。如需指定接受邮箱或手机，请在`邮件正文`中注明。如需要邮寄纸质发票请注明邮寄地址，邮费为到付。\n如邮件发送后三个工作日内未收到回复，请联系 QQ 客服 34731408。\n\n***\n\n#### 可以使用银行转账付款吗？\n\n可以的。请对照[价格表]()，将对应版本的款项转账至：\n\n| 公司名称  | 武汉青罗网络科技有限公司     |\n| ----- | ---------------- |\n| 账号    | 8888888048825564 |\n| 开户行名称 | 浙江网商银行           |\n| 开户地区  | 浙江省杭州市           |\n| 支行名称  | 浙江网商银行股份有限公司     |\n| 联行号   | 323331000001     |\n\n转账完成后请截图发送至 [hi@charmlot.com]() ，并写明注册邮箱，我们将在一个工作日内开通对应服务。\n\n***\n\n#### 可以按月付款吗？\n\n需要月付的客户请联系 QQ 客服 34731408，月付价格为年付价格 / 8。如标准版当前价格为 800 元每年，则月付价格为 100 元每月。\n月付客户需累计支付满 500 元后才能开具发票。`大客户VIP版`不支持月付。\n\n***\n\n#### 大客户方案\n\n如果您的应用有大规模的活跃用户，日均所有应用累计总查询次数超过 100 万次，则建议选择我们专门针对大规模应用优化的`大客户VIP版`。\n`大客户VIP版`在应用数量、原生包数量、热更包数量等方面配额与`专业版`相同。\n\n当前价格如下表：\n\n| 服务版本 | 日均总热更查询次数 | 价格（元/年） |\n| ---- | --------- | ------- |\n| VIP1 | 1000 万次   | 30000   |\n| VIP2 | 5000 万次   | 60000   |\n| VIP3 | 1 亿次      | 120000  |\n| VIP4 | 1 亿次以上    | 请联系客服   |\n\n具体试用和对接请联系 QQ 客服 34731408\n","routePath":"/docs/faq","lang":"en","toc":[{"id":"业务问题","text":"业务问题","depth":3,"charIndex":64},{"id":"热更新究竟能否上架","text":"热更新究竟能否上架？","depth":4,"charIndex":74},{"id":"是否可以在海外使用","text":"是否可以在海外使用？","depth":4,"charIndex":200},{"id":"哪些修改可以热更新哪些不能","text":"哪些修改可以热更新？哪些不能？","depth":4,"charIndex":243},{"id":"热更新成功完成但是重启后又回滚了是怎么回事","text":"热更新成功完成，但是重启后又回滚了是怎么回事？","depth":4,"charIndex":579},{"id":"热更新报错热更新已暂停原因编译时间戳与服务器记录不一致","text":"热更新报错：“热更新已暂停，原因：编译时间戳与服务器记录不一致。”","depth":4,"charIndex":767},{"id":"付费问题","text":"付费问题","depth":3,"charIndex":1687},{"id":"我应该选择哪个业务版本呢","text":"我应该选择哪个业务版本呢？","depth":4,"charIndex":1697},{"id":"我可以试用付费版本先评估一下效果吗","text":"我可以试用付费版本先评估一下效果吗？","depth":4,"charIndex":1982},{"id":"配额具体如何计算","text":"配额具体如何计算？","depth":4,"charIndex":2184},{"id":"达到配额后还可以正常使用吗","text":"达到配额后还可以正常使用吗？","depth":4,"charIndex":2686},{"id":"我可以单独升级某项配额吗","text":"我可以单独升级某项配额吗？","depth":4,"charIndex":2945},{"id":"付费业务到期后不续费现有应用还能否正常使用","text":"付费业务到期后不续费，现有应用还能否正常使用？","depth":4,"charIndex":3065},{"id":"如何获取付费的专人技术支持","text":"如何获取付费的专人技术支持？","depth":4,"charIndex":3182},{"id":"如何开具发票","text":"如何开具发票？","depth":4,"charIndex":3286},{"id":"可以使用银行转账付款吗","text":"可以使用银行转账付款吗？","depth":4,"charIndex":3467},{"id":"可以按月付款吗","text":"可以按月付款吗？","depth":4,"charIndex":3784},{"id":"大客户方案","text":"大客户方案","depth":4,"charIndex":3919}],"frontmatter":{"order":23,"title":"常见问题","type":"其他"},"version":""},{"title":"安装配置","content":":::info\n请注意，当前版本的api经过了完全重构，与之前的版本(v10.0以下)不兼容。如果你需要查看之前版本的文档，请点击[这里]()\n:::\n\n首先你应该有一个基于 React Native 开发的应用，我们把具有 package.json 的目录叫做你的`应用根目录`。\n如果你还没有初始化应用，请参阅[开始使用 React Native]()。\n\n我们假设你已经拥有了开发 React Native 应用的一切环境，包括`Node.js`、`Xcode`、`Android SDK`等等。\n\n<Steps>\n### 安装\n\n在你的项目根目录下运行以下命令（如果你使用 yarn 等其他包管理器，请自行替换命令）：\n\n<Tabs>\n<Tab label=\"React Native\">\n\n```bash\n# 先全局安装命令行工具\nnpm i -g react-native-update-cli\n\n# 然后在项目目录中安装热更新模块\nnpm i react-native-update\n\n# 如果没有使用 expo，则进入 iOS 目录安装 iOS 模块\ncd ios && pod install\n\n```\n\n</Tab>\n\n<Tab label=\"Expo\">\n\n```bash\n# 先全局安装命令行工具\nnpm i -g react-native-update-cli\n\n# 然后在项目目录中安装热更新模块\nnpm i react-native-update\n\n# 如果使用 expo, 要求 expo 50 或更高版本，需要使用 prebuild 命令预构建项目\nnpx expo prebuild\n\n# 然后进入 iOS 目录安装 iOS 模块\ncd ios && pod install\n\n```\n\n:::warning\n注意：如果使用\nexpo，请不要同时安装`expo-updates`，否则会导致热更新功能冲突。另外，expo 51\n版本以下的新架构支持并不完整，可能无法正常使用。如需使用新架构，建议使用尽可能新的\nexpo 版本。\n:::\n\n</Tab>\n</Tabs>\n\n:::info\n如果下载极慢或者显示网络失败，请设置使用淘宝镜像 `npx nrm use taobao`\n:::\n\n:::warning\n注意请不要混用`npm/yarn/pnpm`等包管理器及对应的`lock`文件，团队成员请坚持使用同一包管理器，且仅保留统一格式的`lock`文件\n:::\n\n:::info\n请记得，任意在 ios 和 android 目录下的修改，一定要重新编译（使用 npx\nreact-native run-ios 或 run-android 命令编译，或在 Xcode/Android Studio\n中重新编译）才能生效。\n:::\n\n### 手动 link\n\n如果 RN 版本 >= 0.60 则不需要此手动 link 步骤。\n\n:::warning\n注意：如果是混编 RN\n项目，或monorepo，或任何其他自定义的情况，由于自定义的配置可能不完整或不适应RN的目录结构，导致自动\nlink 的功能可能不能正常工作。此时即便 RN 版本 >= 0.60，你可能也需要执行手动\nlink 操作。\n:::\n\n#### iOS\n\n<details>\n<summary>RN &lt; 0.60且使用CocoaPods（推荐）</summary>\n\n1. 在 ios/Podfile 中添加\n\n```\npod 'react-native-update', path: '../node_modules/react-native-update'\n```\n\n2. 在项目的 ios 目录下运行`pod install`\n3. 重新编译\n\n</details>\n\n<details>\n<summary>RN &lt; 0.60且不使用CocoaPods</summary>\n\n1. 在 XCode 中的 Project Navigator 里,右键点击`Libraries` ➜ `Add Files to [你的工程名]`\n2. 进入`node_modules` ➜ `react-native-update` ➜ `ios 并选中`RCTPushy.xcodeproj\\`\n3. 在 XCode 中的 project navigator 里,选中你的工程,在 `Build Phases` ➜ `Link Binary With Libraries` 中添加 `libRCTPushy.a`、`libz.tbd`、`libbz2.1.0.tbd`\n4. 继续在`Build Settings`里搜索`Header Search Path`，添加`$(SRCROOT)/../node_modules/react-native-update/ios`，勾选`recursive`。\n5. 在`Build Phases`添加一个`New Run Script Phase`运行脚本，内容如下\n\n```\n#!/bin/bash\nset -x\nDEST=\"../node_modules/react-native-update/ios/\"\ndate +%s > \"$DEST/pushy_build_time.txt\"\n```\n\n7. 尝试编译一下，顺利的话就会在`../node_modules/react-native-update/ios/`文件夹下面生成一个`pushy_build_time.txt`文件。然后在`Copy Bundle Resources`里把生成的`pushy_build_time.txt`文件添加进去。\n\n</details>\n\n#### Android\n\n<details>\n<summary>RN &lt; 0.60 或其他不能自动 link 的情况</summary>\n\n1. 在`android/settings.gradle`中添加如下代码:\n\n   ```\n   include ':react-native-update'\n   project(':react-native-update').projectDir = new File(rootProject.projectDir, \t'../node_modules/react-native-update/android')\n   ```\n\n2. 在`android/app/build.gradle`的 dependencies 部分增加如下代码:\n\n   ```\n   implementation project(':react-native-update')\n   ```\n\n3. 打开`android/app/src/main/java/[...]/MainApplication.java`,\n\n- 在文件开头增加 `import cn.reactnative.modules.update.UpdatePackage;`\n- 在`getPackages()` 方法中增加 `new UpdatePackage()`(注意上一行可能要增加一个逗号)\n\n</details>\n\n### 配置 Bundle URL\n\n如果你使用 `expo` 48 或更高版本，且 `react-native-update` >= 10.28.2，则可以自动配置 bundle url，请直接去往[下一个步骤]()。\n如果你没有使用 `expo`，或 `expo` 版本低于 48，则需要按以下步骤手动配置。\n\n#### iOS\n\n在你的 AppDelegate.mm 或 AppDelegate.m 或 AppDelegate.swift 文件（不同 RN 版本可能后缀名不同）中增加如下代码：\n\n:::warning\n注意：如果你是混编原生的项目，务必注意**不能直接指定 bundleURL 来初始化**\nrootView，需要先使用`initWithDelegate`方法来初始化\nbridge，然后使用`initWithBridge`方法来初始化\nrootView。否则热更新功能可能无法正常工作。\n:::\n\n<Tabs>\n<Tab label=\"Objective-C\">\n\n```c\n// ... 其它代码\n#import \"AppDelegate.h\"\n\n#import \"RCTPushy.h\"  // <-- import头文件，注意要放到if条件外面\n\n// 可能项目里有一些条件编译语句，例如有些版本RN自带的flipper\n// #if DEBUG\n// 注意**不要**在这里面引入\"RCTPushy.h\"\n// #import <FlipperKit/FlipperClient.h>\n// ...\n// #endif\n\n\n// rn 版本 >= 0.74 需要修改 bundleURL 方法\n- (NSURL *)bundleURL\n{\n#if DEBUG\n  // 原先DEBUG这里的写法不作修改\n  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\"];\n#else\n  return [RCTPushy bundleURL];  // <--  把这里非DEBUG的情况替换为热更新bundle\n#endif\n}\n\n\n// rn 版本 < 0.74 需要修改sourceURLForBridge方法\n- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge\n{\n#if DEBUG\n  // 原先DEBUG这里的写法不作修改\n  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\"];\n#else\n  return [RCTPushy bundleURL];  // <--  把这里非DEBUG的情况替换为热更新bundle\n#endif\n}\n\n```\n\n</Tab>\n<Tab label=\"Swift\">\n\n```swift\nimport UIKit\nimport React\nimport React_RCTAppDelegate\nimport ReactAppDependencyProvider\nimport react_native_update    // <-- 在这里引入，需要 pushy v10.22.0+ 版本\n\n\n@main\nclass AppDelegate: RCTAppDelegate {\n  // ... 其他代码\n\n  override func bundleURL() -> URL? {\n#if DEBUG\n    // 原先 DEBUG 这里的写法不作修改(所以 DEBUG 模式下不可热更新)\n    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: \"index\")\n#else\n    RCTPushy.bundleURL()  // <--  把这里非 DEBUG 的情况替换为热更新 bundle\n#endif\n  }\n}\n```\n\n</Tab>\n</Tabs>\n\n#### Android\n\n在 MainApplication 中增加如下代码（如果是混编原生的项目或其他原因没有使用 ReactApplication，请[使用此 api 集成]())：\n\n<Tabs>\n<Tab label=\"Kotlin（RN 0.82 或以上）\">\n\n```kotlin\n// ... 其它代码\n\n// ↓↓↓请注意不要少了这句import\nimport cn.reactnative.modules.update.UpdateContext\n// ↑↑↑\n\nclass MainApplication : Application(), ReactApplication {\n\n  override val reactHost: ReactHost by lazy {\n    getDefaultReactHost(\n      context = applicationContext,\n      packageList =\n        PackageList(this).packages.apply {\n          // Packages that cannot be auto-linked yet can be added manually here, for example:\n          // add(MyReactNativePackage())\n        },\n      // ↓↓↓ 添加下面这一段参数\n      jsBundleFilePath = UpdateContext.getBundleUrl(this),\n      // ↑↑↑\n    )\n  }\n\n  // ...其他代码\n}\n\n\n```\n\n</Tab>\n<Tab label=\"Kotlin（RN 0.81 或以下）\">\n\n```kotlin\n// ... 其它代码\n\n// ↓↓↓请注意不要少了这句import\nimport cn.reactnative.modules.update.UpdateContext\n// ↑↑↑\n\nclass MainApplication : Application(), ReactApplication {\n\n  override val reactNativeHost: ReactNativeHost =\n      object : DefaultReactNativeHost(this) {\n\n        // ↓↓↓将下面这一段添加到 DefaultReactNativeHost 内部！\n        override fun getJSBundleFile(): String? {\n          return UpdateContext.getBundleUrl(this@MainApplication)\n        }\n        // ↑↑↑\n\n        // ...其他代码\n      }\n}\n```\n\n</Tab>\n<Tab label=\"Java\">\n\n```java\n// ... 其它代码\n\n// ↓↓↓请注意不要少了这句import\nimport cn.reactnative.modules.update.UpdateContext;\n// ↑↑↑\n\npublic class MainApplication extends Application implements ReactApplication {\n\n  private final ReactNativeHost mReactNativeHost =\n    // 老版本 RN 这里可能是 new ReactNativeHost(this)\n    new DefaultReactNativeHost(this) {\n\n    // ↓↓↓将下面这一段添加到 DefaultReactNativeHost 内部！\n    @Override\n    protected String getJSBundleFile() {\n        return UpdateContext.getBundleUrl(MainApplication.this);\n    }\n    // ↑↑↑\n\n    // ...其他代码\n  }\n}\n```\n\n</Tab>\n</Tabs>\n\n:::info\n请记得，任意在 ios 和 android 目录下的修改，一定要重新编译（npx react-native\nrun-ios 或 run-android 命令编译，或在 Xcode/Android Studio\n中重新编译）才能生效。\n:::\n\n#### Harmony\n\n在 `harmony/entry/src/main/cpp/CMakeLists.txt` 中增加如下依赖：\n\n```c\nadd_subdirectory(\"${OH_MODULES}/pushy/src/main/cpp\" ./pushy)\ntarget_link_libraries(rnoh_app PUBLIC rnoh_pushy)\n```\n\n在 `harmony/entry/src/main/cpp/PackageProvider.cpp` 中增加如下依赖：\n\n```c\n#include \"RNOH/PackageProvider.h\"\n#include \"PushyPackage.h\"\nusing namespace rnoh;\n\nstd::vector<std::shared_ptr<Package>> PackageProvider::getPackages(Package::Context ctx) {\n    return {\n         std::make_shared<PushyPackage>(ctx)\n    };\n}\n```\n\n在 `harmony/entry/oh-package.json5` 中增加如下依赖：\n\n```json5\n\"dependencies\": {\n  \"pushy\": \"file:../../node_modules/react-native-update/harmony/pushy\",\n\n}\n```\n\n在 `harmony/build-profile.json5` 中增加如下配置：\n\n```json5\n  modules: [\n    // ↓↓↓将下面这一段添加到 modules 内部！\n    {\n      name: 'pushy',\n      srcPath: '../node_modules/react-native-update/harmony/pushy',\n    },\n  ],\n```\n\n在 `harmony/hvigor/hvigor-config.json5` 中增加如下配置：\n\n```json5\n{\n  dependencies: {\n    pushy: \"file:../../node_modules/react-native-update/harmony/pushy\",\n  },\n}\n```\n\n在 `harmony/entry/hvigorfile.ts` 中增加如下配置：\n\n```ts\n\n\n\nexport default {\n  system: hapTasks /* Built-in plugin of Hvigor. It cannot be modified. */,\n  plugins: [\n    reactNativeUpdatePlugin(),\n  ] /* Custom plugin to extend the functionality of Hvigor. */,\n};\n```\n\n在 `harmony/entry/src/main/ets/RNPackagesFactory.ts` 代码如下：\n\n```ts\nimport type {\n  RNPackageContext,\n  RNPackage,\n} from \"@rnoh/react-native-openharmony/ts\";\n\n\nexport function createRNPackages(ctx: RNPackageContext): RNPackage[] {\n  return [new PushyPackage(ctx)];\n}\n```\n\n在 `harmony/entry/src/main/ets/pages/Index.ets` 中增加如下代码：\n\n```ts\n// ... 其它代码\n\n// ↓↓↓请注意不要少了这句\n// ↑↑↑\n\n@Entry\n@Component\nstruct Index {\n  @StorageLink('RNOHCoreContext') private rnohCoreContext: RNOHCoreContext | undefined = undefined\n  @State shouldShow: boolean = false\n\n  aboutToAppear(): void {\n    this.shouldShow = true\n  }\n\n  onBackPress(): boolean | undefined {\n    // NOTE: this is required since `Ability`'s `onBackPressed` function always\n    // terminates or puts the app in the background, but we want Ark to ignore it completely\n    // when handled by RN\n    this.rnohCoreContext!.dispatchBackPress()\n\n    // this.preferences = preferences.getPreferencesSync(this.context, {name:'update'});\n    return true\n  }\n\n  build() {\n    Column() {\n      if (this.rnohCoreContext && this.shouldShow) {\n        RNApp({\n          // ... 其他代码\n          jsBundleProvider: new TraceJSBundleProviderDecorator(\n            new AnyJSBundleProvider([\n              // MetroJSBundleProvider.fromServerIp('127.0.0.1'),\n              // new ResourceJSBundleProvider(rnohCoreContext.uiAbilityContext.resourceManager, 'hermes_bundle.hbc'),\n              // ↓↓↓将下面这一段添加到 AnyJSBundleProvider 内部！\n              new PushyFileJSBundleProvider(this.rnohCoreContext.uiAbilityContext),\n\n              // 注意无论是否使用 hermes 格式，请保持 bundle 文件名为 bundle.harmony.js\n              new ResourceJSBundleProvider(this.rnohCoreContext.uiAbilityContext.resourceManager, 'bundle.harmony.js')\n            ]),\n            this.rnohCoreContext.logger),\n        })\n      }\n    }\n    .height('100%')\n    .width('100%')\n  }\n}\n```\n\n:::info\n请记得，任意在 ios 和 android 目录下的修改，一定要重新编译（npx react-native\nrun-ios 或 run-android 命令编译，或在 Xcode/Android Studio\n中重新编译）才能生效。\n:::\n\n### 覆盖 android 的 onCreate\n\n如果你有安装 `react-native-screens` (使用 `react-navigation` 一般都会要求安装)，则安卓端在热更后重启可能会白屏。此时需要在 Android 的 `MainActivity` 中设置 `RNScreensFragmentFactory`，以确保 Fragment 恢复流程一致，避免崩溃。注意不要把这段覆盖写在 `MainActivityDelegate` 里，而是直接放在 `MainActivity` 中。\n更多说明可以参考 `react-native-screens` 的 [readme]()\n\n<Tabs>\n<Tab label=\"Kotlin\">\n\n```kotlin\n// android/app/src/main/java/[...]/MainActivity.kt\nimport android.os.Bundle\nimport com.swmansion.rnscreens.fragment.restoration.RNScreensFragmentFactory\n\nclass MainActivity : ReactActivity() {\n  // ...其他代码\n\n  override fun onCreate(savedInstanceState: Bundle?) {\n    supportFragmentManager.fragmentFactory = RNScreensFragmentFactory()\n    super.onCreate(savedInstanceState)\n    // 如果你用的版本比较老，没有 RNScreensFragmentFactory，则使用下面的写法\n    // super.onCreate(null)\n  }\n}\n```\n\n</Tab>\n<Tab label=\"Java\">\n\n```java\n// android/app/src/main/java/[...]/MainActivity.java\nimport android.os.Bundle;\nimport com.swmansion.rnscreens.fragment.restoration.RNScreensFragmentFactory;\n\npublic class MainActivity extends ReactActivity {\n  // ...其他代码\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    getSupportFragmentManager().setFragmentFactory(new RNScreensFragmentFactory());\n    super.onCreate(savedInstanceState);\n    // 如果你用的版本比较老，没有 RNScreensFragmentFactory，则使用下面的写法\n    // super.onCreate(null);\n  }\n}\n```\n\n</Tab>\n</Tabs>\n\n### 添加测试用的 Deep Link\n\n此步骤可以极其便利的在和用户完全一致的环境中安全地测试热更新，无需额外的设备注册步骤，也不影响现有的热更新流程。\n\n<Tabs>\n<Tab label=\"Android\">\n\n在 `android/app/src/main/AndroidManifest.xml` 中添加如下代码：\n\n```xml\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\">\n  <application>\n\n    <!-- 其他代码 -->\n\n    <!-- ↓↓↓ 注意 activity 的 launchMode 需要设置为 singleTask -->\n    <activity\n      android:launchMode=\"singleTask\">\n      <!-- ↑↑↑ -->\n\n      <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n      </intent-filter>\n\n      <!-- ↓↓↓ 添加如下 intent-filter， 注意和上面的 intent-filter 是不同的 action 和 category -->\n      <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n        <!-- 添加你自定义的 scheme -->\n        <data android:scheme=\"你自定义的协议名，请不要和常见协议名或其他app冲突\" />\n      </intent-filter>\n      <!-- ↑↑↑ -->\n\n    </activity>\n  </application>\n</manifest>\n```\n\n</Tab>\n<Tab label=\"iOS\">\n\n请参考 [React Native 的文档]()\n\n</Tab>\n</Tabs>\n\n***\n\n在完成上述配置并编译，并且日后上传了热更包，在后台能看到热更版本之后，你就可以将鼠标移到网页后台的二维码图标上，如下图所示：\n\n勾选`使用 Deep Link`选项，在后面的输入框中填入你自定义的协议名，在二维码刷新后，即可在设备上直接使用系统相机或扫码功能（注意不能使用微信扫码）来扫描，即可自动触发热更检查功能。\n\n第一次扫码后可能只是触发服务器任务队列，会弹出提示 10 秒后重新扫码，此时会获得热更包，触发内置或自定义的更新策略。\n\n注意如果你使用自定义的更新策略，请务必从`useUpdate()`中获取`updateInfo`，而不要依赖`checkUpdate`方法的返回值，否则扫码不会有后续动作。\n\n### 禁用 android 的 crunch 优化\n\nandroid 会在生成 apk 时自动对 png 图片进行压缩，此操作既耗时又影响增量补丁的生成。为了保证补丁能正常生成，您需要在`android/app/build.gradle`中关闭此操作：\n\n```groovy\n// 在 android/app/build.gradle 文件中\n\nandroid {\n    // ...\n    signingConfigs {\n      // ...\n    }\n    buildTypes {\n        release {\n            // ...\n            // 添加下面这行以禁用crunch\n            crunchPngs false\n        }\n    }\n}\n\n```\n\n### 禁用 aab 包的资源分割（如果你需要在 Google Play 上架）\n\n如果你需要打 aab 包以在 Google Play 上架，且 react-native-update 版本 低于 10.36.0，则需要禁用 aab 包的资源分割。若已升级到 10.36.0+ 版本，则不需要此设置。\n\n```groovy\n// 在 android/app/build.gradle 文件中\n\nandroid {\n    bundle {\n        density {\n            // 请禁用资源分割\n            // 否则热更后可能遇到图片无法显示的问题\n            // v10.36.0 版本之后不需要此设置\n            enableSplit = false\n        }\n    }\n}\n\n```\n\n### 登录与创建应用\n\n首先请在 [https://pushy-admin.reactnative.cn]() 注册帐号，然后在你的项目根目录下运行以下命令：\n\n```bash\n$ pushy login\nemail: <输入你的注册邮箱>\npassword: <输入你的密码>\n```\n\n这会在项目文件夹下创建一个`.update`文件，注意不要把这个文件上传到 Git 等 CVS 系统上。你可以在`.gitignore`末尾增加一行`.update`来忽略这个文件。\n\n登录之后可以创建应用。注意 iOS 平台、安卓平台、鸿蒙平台需要分别创建：\n\n```bash\n$ pushy createApp --platform ios\nApp Name: <输入应用名字>\n$ pushy createApp --platform android\nApp Name: <输入应用名字>\n$ pushy createApp --platform harmony\nApp Name: <输入应用名字>\n```\n\n:::info\n应用的名字可以相同，这没有关系。\n:::\n\n如果你已经在网页端或者其它地方创建过应用，也可以直接选择应用：\n\n```bash\n$ pushy selectApp --platform ios\n1) 鱼多多(ios)\n2) 招财旺(ios)\n\nTotal 2 ios apps\nEnter appId: <输入应用前面的编号>\n```\n\n选择或者创建过应用后，你将可以在文件夹下看到`update.json`文件，其内容类似如下形式：\n\n```bash\n{\n    \"ios\": {\n        \"appId\": 1,\n        \"appKey\": \"<一串随机字符串>\"\n    },\n    \"android\": {\n        \"appId\": 2,\n        \"appKey\": \"<一串随机字符串>\"\n    },\n    \"harmony\": {\n        \"appId\": 3,\n        \"appKey\": \"<一串随机字符串>\"\n    }\n}\n```\n\n你可以安全的把`update.json`上传到 Git 等 CVS 系统上，与你的团队共享这个文件，它不包含任何敏感信息。当然，他们在使用任何功能之前，都必须首先输入`pushy login`进行登录。\n\n至此应用的创建/选择就已经成功了。下一步，你需要给代码添加相应的功能，请参阅[代码集成]()。\n\n</Steps>\n````\n","routePath":"/docs/getting-started","lang":"en","toc":[{"id":"手动-link","text":"手动 link","depth":3,"charIndex":1186},{"id":"ios","text":"iOS","depth":4,"charIndex":1373},{"id":"android","text":"Android","depth":4,"charIndex":2394},{"id":"配置-bundle-url","text":"配置 Bundle URL","depth":3,"charIndex":3008},{"id":"ios-1","text":"iOS","depth":4,"charIndex":3166},{"id":"android-1","text":"Android","depth":4,"charIndex":4760},{"id":"harmony","text":"Harmony","depth":4,"charIndex":6738},{"id":"覆盖-android-的-oncreate","text":"覆盖 android 的 onCreate","depth":3,"charIndex":10011},{"id":"添加测试用的-deep-link","text":"添加测试用的 Deep Link","depth":3,"charIndex":11377},{"id":"禁用-android-的-crunch-优化","text":"禁用 android 的 crunch 优化","depth":3,"charIndex":12835},{"id":"禁用-aab-包的资源分割如果你需要在-google-play-上架","text":"禁用 aab 包的资源分割（如果你需要在 Google Play 上架）","depth":3,"charIndex":13208},{"id":"登录与创建应用","text":"登录与创建应用","depth":3,"charIndex":13595}],"frontmatter":{"order":0,"title":"安装配置","type":"快速入门"},"version":""},{"title":"代码集成","content":":::info\n请注意，当前版本的api经过了完全重构，与之前的版本(v10.0以下)不兼容。如果你需要查看之前版本的文档，请点击[这里]()\n:::\n\n安装配置完成后，确定应用编译顺利通过，下面我们来进行代码集成。\n\n### 获取 appKey\n\n检查更新时必须提供你的`appKey`，这个值保存在`update.json`中（使用`pushy createApp`或`pushy selectApp`命令后会自动生成），并且根据平台不同而不同。你可以用如下的代码获取`appKey`：\n\n```javascript\n\n\n\nconst { appKey } = _updateConfig[Platform.OS];\n```\n\n也可以在网页端的应用设置中查看应用的 appKey。\n\n### 初始化服务\n\n```js\n\n\n// 唯一必填参数是appKey，其他选项请参阅 api 文档\nconst pushyClient = new Pushy({\n  appKey,\n  // 注意，默认情况下，在开发环境中不会检查更新\n  // 如需在开发环境中调试更新，请设置debug为true\n  // 但即便打开此选项，也仅能检查、下载热更，并不能实际应用热更。实际应用热更必须在release包中进行。\n  // debug: true\n});\n\n// 在根组件外加上 UpdateProvider 后导出\nexport default function Root() {\n  // 注意，在使用 UpdateProvider 的当前组件中，无法直接调用 useUpdate\n  // 只有当前组件的子组件才能调用 useUpdate\n  return (\n    <UpdateProvider client={pushyClient}>\n      {/* ↓ 整个应用的根组件放到 UpdateProvider 中 */}\n      <App />\n    </UpdateProvider>\n  );\n}\n```\n\n如没有特别的自定义需求，那么到此热更新已经可以开始正常运作（如需在应用内执行 apk 更新，还需配置[安装权限]()）。在默认的配置下，在 App 启动，以及从后台切换到前台时会触发更新检查，弹出提示的内容也固定。\n\n如需简单调整检查和更新策略，可参考以下内置的策略参数：\n\n#### checkStrategy（检查更新策略）\n\n用于控制自动检查更新的触发时机：\n\n- `\"both\"`（默认值）：在 App 启动时和从后台切换到前台时都会检查更新\n- `\"onAppStart\"`：仅在 App 启动时检查更新\n- `\"onAppResume\"`：仅在 App 从后台切换到前台时检查更新\n- `null`：不自动检查更新，必须手动调用 `checkUpdate` 方法（需 v10.4.2+ 版本）\n\n示例：\n\n```js\nconst pushyClient = new Pushy({\n  appKey,\n  checkStrategy: \"onAppStart\", // 仅在启动时检查\n});\n```\n\n#### updateStrategy（更新应用策略）\n\n用于控制检测到更新后的自动下载和应用行为：\n\n- `\"alwaysAlert\"`：调试环境（`__DEV__`）的默认值，使用系统 alert 提示热更，并在有报错时弹出提示\n- `\"alertUpdateAndIgnoreError\"`：生产环境的默认值，有热更时使用系统 alert 提示，但不弹出报错提示\n- `\"silentAndNow\"`：自动静默下载并立即应用热更（会立即重启应用）\n- `\"silentAndLater\"`：自动静默下载，但仅在用户杀掉 App 后重启时应用更新\n- `null`：不自动下载和应用更新，需完全自定义热更界面\n\n示例：\n\n```js\nconst pushyClient = new Pushy({\n  appKey,\n  updateStrategy: \"silentAndLater\", // 静默下载，下次启动时更新\n});\n```\n\n检查策略和更新策略是一个完整更新流水线的上下游，两者可以独立开关，自由搭配，以便不同程度的介入检查频率的控制，或是下载相关的界面交互。\n\n下面的章节提供了一个自定义更新策略和界面交互的参考实现。\n\n### 自定义更新界面\n\n默认配置下，pushy 会以系统 alert 的形式来弹出更新提示，如需自定义更新界面，首先请关闭默认的 updateStrategy 更新策略，并打开 debug 选项以便调试：\n\n```diff\nconst pushyClient = new Pushy({\n  appKey,\n+  updateStrategy: null,\n+  debug: true,\n});\n```\n\n所有更新相关的数据可以通过一个单一的[`useUpdate()`]()hook 函数来获取，然后可以根据其提供的数据来自行渲染自定义的界面，如下面的例子：\n\n```js\n\n\n\nfunction App() {\n  const {\n    client,\n    checkUpdate,\n    downloadUpdate,\n    switchVersionLater,\n    switchVersion,\n    updateInfo,\n    packageVersion,\n    currentHash,\n    progress: { received, total } = {},\n  } = useUpdate();\n  const [showUpdateBanner, setShowUpdateBanner] = useState(false);\n  const [showUpdateSnackbar, setShowUpdateSnackbar] = useState(false);\n  const snackbarVisible = showUpdateSnackbar && updateInfo?.update;\n  return (\n    <View style={styles.container}>\n      <Text>\n        更新下载进度：{received} / {total}\n      </Text>\n      <TouchableOpacity\n        onPress={() => {\n          checkUpdate();\n          setShowUpdateSnackbar(true);\n        }}\n      >\n        <Text>点击这里检查更新</Text>\n      </TouchableOpacity>\n      {snackbarVisible && (\n        <Snackbar\n          visible={true}\n          onDismiss={() => {\n            setShowUpdateSnackbar(false);\n          }}\n          action={{\n            label: \"更新\",\n            onPress: async () => {\n              setShowUpdateSnackbar(false);\n              if (await downloadUpdate()) {\n                setShowUpdateBanner(true);\n              }\n            },\n          }}\n        >\n          <Text>有新版本({updateInfo.name})可用，是否更新？</Text>\n        </Snackbar>\n      )}\n      <Banner\n        style={{ width: \"100%\", position: \"absolute\", top: 0 }}\n        visible={showUpdateBanner}\n        actions={[\n          {\n            label: \"立即重启\",\n            onPress: switchVersion,\n          },\n          {\n            label: \"下次再说\",\n            onPress: () => {\n              switchVersionLater();\n              setShowUpdateBanner(false);\n            },\n          },\n        ]}\n        icon={({ size }) => (\n          <Icon name=\"checkcircleo\" size={size} color=\"#00f\" />\n        )}\n      >\n        更新已完成，是否立即重启？\n      </Banner>\n    </View>\n  );\n}\n```\n\n其中`checkUpdate`方法可以用来手动触发更新检查。虽然这个方法会返回[`updateInfo`]()（仅限 v10.26.0+ 版本），但我们仍然推荐优先使用`useUpdate()`来获取`updateInfo`。\n\n:::info\n依赖`useUpdate()`而不是`checkUpdate`来获取`updateInfo`，这样做虽然一开始可能觉得不太直观，但可以将**检查逻辑**和**更新逻辑**完全解耦，使更新流程上的各个组件不需要互相依赖和影响。\n比如检查更新的按钮只管调用`checkUpdate`，某个显示小红点的组件只管从 `useUpdate()` 中获取`updateInfo`，而主要的下载流程可以写一个单独的`useEffect`，这几者之间并不需要考虑先后顺序、组件层级或者传递数据。\n又比如你可能在多处都有检查更新的调用，比如 app 启动时、前后台切换时，又或者使用 deeplink 和扫码，这些不同的检查逻辑也不用重复去实现后续的更新逻辑。\n:::\n\n`updateInfo` 有三种情况：\n\n1. `{expired: true}`：该应用原生包已过期（三种情况：1. 主动设置为过期状态，2. 主动删除，3. 从未上传），开发者应该在 pushy 的管理后台添加一个更新下载链接，并自行提示用户下载。如需在应用内执行 apk 更新，还需配置[安装权限]()。\n\n2. `{upToDate: true}`：当前已经更新到最新，无需进行更新。\n\n3. `{update: true}`：当前有新版本可以更新。info 的`name`、`description`字段可以用于提示用户，而`metaInfo`字段则可以根据你的需求自定义其它属性(如是否静默更新、是否强制更新等等)，具体用法可参考[场景实践]()。另外还有几个字段，包含了补丁包的下载地址等。 pushy 会首先尝试耗费流量更少的更新方式。\n\n当返回的`updateInfo`中`update`字段为 true 时，即可调用`downloadUpdate`方法来下载更新，此时可以获取到下载的进度数据`progress`。下载完成后（注意!不可依赖`progress`来判断下载完成，必须要`await downloadUpdate()`之后）可以调用`switchVersion`来立即重启更新，也可以使用`switchVersionLater`来标记下次启动时更新。\n\n### 统计数据\n\n初始化 Pushy 客户端时可以传入自定义的 logger 函数，其中可以自己记录日志或上报统计数据，比如下面的例子使用 Google Analytics 来上报事件：\n\n```ts\n\nconst analytics = getAnalytics();\n\nconst pushyClient = new Pushy({\n  appKey,\n  logger: ({ type, data }) => {\n    logEvent(analytics, \"pushy_\" + type, data);\n  },\n});\n```\n\n以上提及的所有 api 的说明文档可在[这里]()查看。还有一些其他常见的场景可以参考[场景实践]()。\n\n现在，你的应用已经可以通过 pushy 服务检查版本并进行更新了。下一步，你可以开始尝试发布应用包和版本，请参阅[发布热更新]()。\n","routePath":"/docs/integration","lang":"en","toc":[{"id":"获取-appkey","text":"获取 appKey","depth":3,"charIndex":110},{"id":"初始化服务","text":"初始化服务","depth":3,"charIndex":344},{"id":"checkstrategy检查更新策略","text":"checkStrategy（检查更新策略）","depth":4,"charIndex":1002},{"id":"updatestrategy更新应用策略","text":"updateStrategy（更新应用策略）","depth":4,"charIndex":1322},{"id":"自定义更新界面","text":"自定义更新界面","depth":3,"charIndex":1843},{"id":"统计数据","text":"统计数据","depth":3,"charIndex":4998}],"frontmatter":{"order":1,"title":"代码集成","type":"快速入门"},"version":""},{"title":"产品简介","content":":::info\n**现已全面支持鸿蒙系统以及 React Native 新架构！**\n:::\n\nPushy (npm 包名: [`react-native-update`]() <a href=\"https://www.npmjs.com/package/react-native-update\">\\<img src=\"[https://badge.fury.io/js/react-native-update.svg]()\" alt=\"npm version\" style={{display: 'inline', verticalAlign: 'middle', margin: '0 4px'}} /></a>) 是面向 React Native 应用提供的**专业热更新服务**，由 [React Native 中文网]()独家研发并持续维护。我们致力于为全球 React Native 开发者提供最快速、最稳定、最经济的热更新体验。\n\n## 🚀 为什么选择 Pushy？\n\n### 极致的更新体验\n\n- **🎯 超小更新包**：基于 bsdiff/hdiff 算法的增量更新，通常只需**几十至几百 KB**（相比其他全量更新服务的几十 MB，节省流量 99%+）\n- **⚡️ 极速分发**：国内用户使用阿里云高速 CDN，国外用户智能分流至 Cloudflare，在各地区都使用覆盖率最好的 CDN 服务商，更新成功率高达 **99.9%+**\n- **🛡️ 安全可靠**：内置崩溃回滚机制，出现问题自动回退，确保应用稳定运行\n- **🌐 全平台覆盖**：完美支持 \\<AppleOutlined style={{fontSize: '16px', color: '#555', marginRight: '6px'}} /> **iOS** \\<AndroidOutlined style={{fontSize: '16px', color: '#3DDC84', marginRight: '6px'}} /> **Android**, 且业内独家第一方支持 \\<HarmonyOSOutlined style={{fontSize: '16px', color: '#000', marginRight: '6px'}} /> **鸿蒙（HarmonyOS）**\n- **🔍 深耕 React Native 生态**：\n  - ✅ **Expo** - 无缝集成\n  - ✅ **新架构** - 第一时间跟进支持\n  - ✅ **Hermes** - 完整支持字节码格式\n- **📖 核心逻辑完全开源**：客户端、命令行工具以及管理界面代码都[完全开源]()，接受社区审计，代码透明可信，你可以随时迁移到自建服务器或其他服务\n- **🔒 数据安全**：可以自行插入数据埋点，完全掌控自己的数据\n- **💬 专业人工支持**：提供付费专人技术支持，有问必答，确保你的应用稳定运行\n- **🏆 多年稳定运营**：从 2016 年开始运营至今，服务众多知名企业和应用\n\n## 💰 性价比之选\n\n相比同类服务，Pushy 不仅功能更强大，价格也更亲民：\n\n| 对比项       | Pushy        | Expo Update |\n| --------- | ------------ | ----------- |\n| **起步价**   | ¥66/月        | \\~¥136/月    |\n| **流量计费**  | 不单独计费        | 超出需额外付费     |\n| **更新包大小** | 几十至几百 KB（增量） | 几十 MB（全量）   |\n| **国内速度**  | ⭐⭐⭐⭐⭐ 极快     | ⭐⭐ 较慢       |\n| **鸿蒙支持**  | ✅ 支持         | ❌ 不支持       |\n\n:::warning\n**注意**：Microsoft App Center（Code Push）已于 2025 年 3 月 31 日正式停止服务。如果你正在使用 Code Push，现在正是迁移到 Pushy 的最佳时机！\n:::\n\n使用 Pushy 后，你的团队将获得：\n\n- ✅ **节省 90% 以上的流量成本**\n- ✅ **发版速度提升 10 倍以上**（无需等待应用商店审核）\n- ✅ **Bug 修复时间缩短至分钟级**\n- ✅ **用户更新率提升至 99%+**（相比应用商店的自然更新率）\n- ✅ **开发迭代更加灵活自由**\n\n### 简单易用\n\n```js\n// 三行代码即可集成\n\n\nconst pushyClient = new Pushy({ appKey });\n\n<UpdateProvider client={pushyClient}>\n  <App />\n</UpdateProvider>\n```\n\n内置多种更新策略，开箱即用：\n\n- 🔕 **静默更新** - 后台自动下载，用户无感知\n- 💬 **提示更新** - 友好的系统弹窗提醒\n- ⚙️ **自定义策略** - 完全可控的更新流程\n\n## 🚦 开始使用\n\n只需三步，即可为你的 React Native 应用添加热更新能力：\n\n1. **[安装配置]()** - 5 分钟完成基础配置\n2. **[代码集成]()** - 几行代码即可接入\n3. **[发布更新]()** - 一条命令推送新版本\n\n:::info\n不确定是否适合你的项目？查看[常见问题]()或者可以去[issues 区]()或 QQ 群 729013783 提问，或给我们发[邮件]()。\n:::\n\n立即开始使用 Pushy，让你的 React Native 应用拥有极致的热更新体验！\n","routePath":"/docs/intro","lang":"en","toc":[{"id":"-为什么选择-pushy","text":"🚀 为什么选择 Pushy？","depth":2,"charIndex":423},{"id":"极致的更新体验","text":"极致的更新体验","depth":3,"charIndex":443},{"id":"-性价比之选","text":"💰 性价比之选","depth":2,"charIndex":1301},{"id":"简单易用","text":"简单易用","depth":3,"charIndex":1921},{"id":"-开始使用","text":"🚦 开始使用","depth":2,"charIndex":2165}],"frontmatter":{"order":0,"title":"产品简介","type":"关于"},"version":"","description":":::info\n现已全面支持鸿蒙系统以及 React Native 新架构！\n::: Pushy (npm 包名: react-native-update <a href=\"https://www.npmjs.com/package/react-native-update\"><img src=\"https://badge.fury.io/js/react-native-update.svg\" alt=\"npm version\" style={{display: 'inline', verticalAlign: 'middle', margin: '0 4px'}} /></a>) 是面向 React Native 应用提供的专业热更新服务，由 React Native 中文网独家研发并持续维护。我们致力于为全球 React Native 开发者提供最快速、最稳定、最经济的热更新体验。"},{"title":"发布热更新","content":"现在你的应用已经具备了检测更新的功能，下面我们来尝试发布并更新它。流程可参考下图：\n\n```mermaid\nflowchart TD\n    codebase[\"🖥️&nbsp;&nbsp;项目代码库\"]\n    subgraph 发布原生基准版本\n    tagNativeVersion[\"🏷️&nbsp;&nbsp;(在 git 上)标记原生版本号\"]\n    newNativeVersion[\"🗂️&nbsp;&nbsp;新的原生基准版本\"]\n    nativePackage[\"📦&nbsp;&nbsp;原生完整包(apk或ipa文件)\"]\n    tagNativeVersion--\"🔨&nbsp;&nbsp;编译\"-->nativePackage\n    nativePackage--\"⬆️&nbsp;&nbsp;使用<br/>pushy uploadApk/uploadIpa<br/>命令上传\"-->newNativeVersion\n    end\n    subgraph 发布热更新版本\n    tagBundleVersion[\"🏷️&nbsp;&nbsp;(在 git 上)标记热更新版本号\"]\n    bundlePackage[\"🎁&nbsp;&nbsp;js代码与资源包(ppk文件)\"]\n    tagBundleVersion--\"🔨&nbsp;&nbsp;使用<br/>pushy bundle<br/>命令生成并上传\"-->bundlePackage\n    someNativeVersions[\"🗂️&nbsp;&nbsp;一个或多个原生基准版本\"]\n    bundlePackage--\"🖇️&nbsp;&nbsp;绑定\"-->someNativeVersions\n    end\n    user[\"👨‍👩‍👧‍👦&nbsp;&nbsp;安装有对应原生基准版本的用户\"]\n    codebase--\"✏️&nbsp;&nbsp;改动js代码，<br/>或添加、更新js组件，<br/>或添加、更新js代码中引用的图片等资源\"-->发布热更新版本\n    codebase--\"🖊️&nbsp;&nbsp;改动原生代码、设置，<br/>或添加、更新原生组件，<br/>或添加、更新原生代码中引用的图片等资源\"-->发布原生基准版本\n    发布热更新版本--\"📲&nbsp;&nbsp;推送增量热更新(diff文件)\"-->user\n```\n\n流程总结如下：\n\n1. 我们需要先打包一个原生 release 版本，在打包前请确保已集成了`react-native-update`并在调试过程中运行正常，安卓端[关闭了`crunchPngs`设置]()，打包说明可参考[iOS 打包]()和[android 打包]()。打包完成后请使用`pushy uploadIpa`或者`pushy uploadApk`命令来把这个安装包上传到 pushy 服务器端，以作为之后热更差量对比的基准。同时请保留好这个安装包，上架和分发给用户所使用的安装包`需要和服务器端完全一致`。建议使用 git tag 功能来标记原生版本号（例如`v1.0.0`）。\n2. 然后在基准版本之上迭代业务逻辑（增删 js 代码，增删图片等静态资源），使用`pushy bundle`命令来生成和发布热更新版本，而不需要重新打包。建议使用 git tag 功能来标记热更版本号（例如`v1.0.1`）。\n3. 如果迭代过程中有原生方面的修改，则需要发布并上传新的原生基准版本（重复步骤 1，但需要设置不同的原生版本号）。可以只保留一个原生基准版本，也可以多版本同时维护。\n\n## 发布原生基准版本\n\n### iOS\n\n首先参考[文档-在设备上运行]()，确定你正在使用离线包。然后点击菜单。\n\n按照正常的发布流程打包`.ipa`文件：\n\n1. Xcode 中运行设备选真机或 Generic iOS Device\n2. 菜单中选择 Product - Archive\n3. Archive 完成后选择`Export`生成.ipa 文件\n4. 然后运行如下命令上传到 pushy 服务器以供后续版本比对之用\n\n```bash\n$ pushy uploadIpa <ipa后缀文件>\n```\n\n此 ipa 的`CFBundleShortVersionString`字段(位于`ios/项目名/Info.plist`中)会被记录为原生版本号`packageVersion`。\n\n随后你可以选择往 AppStore 上传这个版本（可以重新 export 并调整相关选项，但请不要重新 archive），也可以先通过[Test flight]()或[蒲公英]()等渠道进行真机安装测试。请注意：暂不支持通过 Xcode 直接进行热更新测试。\n\n如果后续需要再次 archive 打包（例如修改原生代码或配置。如果只是修改 js 代码则不需要重新打包。），请先**更改版本号**，并在打包完成后再次`uploadIpa`到服务器端记录，否则后续生成的相同版本的原生包会由于[编译时间戳不一致而`无法获取热更新`]()。\n\n### Android\n\n首先参考[文档-打包 APK]()设置签名，然后在 android 文件夹下运行`./gradlew assembleRelease`或`./gradlew aR`，你就可以在`android/app/build/outputs/apk/release/app-release.apk`中找到你的应用包。\n\n然后运行如下命令\n\n```bash\n$ pushy uploadApk android/app/build/outputs/apk/release/app-release.apk\n# 如果你打的是 aab 格式的包，则请使用以下命令\n# pushy uploadAab android/app/build/outputs/bundle/release/app-release.aab\n```\n\n即可上传 apk 以供后续版本比对之用。此 apk 的`versionName`字段(位于`android/app/build.gradle`中)会被记录为原生版本号`packageVersion`。\n\n随后你可以选择往应用市场发布这个版本，也可以先往设备上直接安装这个 apk 文件以进行测试。\n\n如果后续需要再次打包（例如修改原生代码或配置。如果只是修改 js 代码则不需要重新打包。），请先**更改版本号**，并再次`uploadApk`到服务器端记录，否则后续生成的相同版本的原生包会由于[编译时间戳不一致而`无法获取热更新`]()。\n\n### Harmony\n\n首先下载鸿蒙开发IDE DevEco-Studio，然后通过Build => Build Hap(s)/App(s) => Build App(s)，你就可以在`harmony/build/outputs/default/harmony-default-unsigned.app`中找到你的应用包。\n\n然后运行如下命令\n\n```bash\n$ pushy uploadApp harmony/build/outputs/default/harmony-default-unsigned.app\n```\n\n即可上传 app 以供后续版本比对之用。此 app 的`versionName`字段(位于`harmony/AppScope/app.json5`中)会被记录为原生版本号`packageVersion`。\n\n随后你可以选择往华为应用市场发布这个版本，也可以先往设备上通过命令`hdc shell`命令安装这个 app 文件以进行测试。\n\n如果后续需要再次打包（例如修改原生代码或配置。如果只是修改 js 代码则不需要重新打包。），请先**更改版本号**，并再次`uploadApp`到服务器端记录，否则后续生成的相同版本的原生包会由于[编译时间戳不一致而`无法获取热更新`]()。\n\n## 发布热更新版本\n\n你可以尝试修改一行代码(譬如将版本一修改为版本二)，然后使用`pushy bundle --platform <ios|android|harmony>`命令来生成新的热更新版本。\n\n:::info\n如果你使用了较新版本的`expo`或其他没有`index.js`的框架，执行`bundle`命令时会报错。此时请手动创建一个`index.js`文件，在其中引用框架自身的入口文件即可。具体入口文件的路径如何，请参考框架的说明文档或者`package.json`中的`main`字段。例如针对`expo`的`index.js`可能是如下这样写：\n\n```js\nimport \"expo-router/entry\";\n```\n\n:::\n\n```bash\n$ pushy bundle --platform android\nBundling with React Native version:  0.22.2\n<各种进度输出>\nBundled saved to: build/output/android.1459850548545.ppk\nWould you like to publish it?(Y/N)\n```\n\n如果想要立即上传，此时输入 Y。当然，你也可以在将来使用`pushy publish --platform android build/output/android.1459850548545.ppk`来上传刚才打包好的热更新包。\n\n```\n  Uploading [========================================================] 100% 0.0s\nEnter version name: <输入热更新版本名字，如1.0.0-rc>\nEnter description: <输入热更新版本描述>\nEnter meta info: {\"ok\":1}\nOk.\nWould you like to bind packages to this version?(Y/N)\n```\n\n此时版本已经提交到 pushy 服务，但用户暂时看不到此更新，你需要先将特定的原生包版本绑定到此热更新版本上。\n\n此时输入 Y 立即绑定，你也可以在将来使用`pushy update --platform <ios|android|harmony>`来对已上传的热更包和原生包进行绑定。除此以外，你还可以在网页端操作，简单的将对应的原生包版本拖到需要的热更新版本下即可。\n\n```\n┌────────────┬──────────────────────────────────────┐\n│ Package Id │               Version                │\n├────────────┼──────────────────────────────────────┤\n│   46272    │ 2.0(normal)                          │\n├────────────┼──────────────────────────────────────┤\n│   45577    │ 1.0(normal)                          │\n└────────────┴──────────────────────────────────────┘\n共 2 个包\n输入原生包 id: 46272\n```\n\n版本绑定完毕后，服务器会在几秒内生成差量补丁，客户端就可以获取到更新了。\n\n后续要继续发布新的热更新，只需反复执行`pushy bundle`命令即可，不需要重新打包。\n\n恭喜你，至此为止，你已经完成了植入代码热更新的全部工作。\n\n## 灰度发布\n\n灰度发布（又称金丝雀发布、渐进式发布）是一种降低热更新发布风险的策略，通过逐步扩大更新范围来验证新版本的稳定性。\n\n### 什么是灰度发布\n\n灰度发布是指在正式全量发布热更新之前，先将更新推送给一小部分用户（如 5%、10%），观察这部分用户的使用情况后，再逐步扩大更新比例，直到最终推送给所有用户。\n\n### 灰度发布的作用\n\n- **降低风险**：如果新版本存在 bug，只会影响小部分用户，可以及时发现并回滚\n- **验证稳定性**：通过小范围用户的真实使用反馈，验证新版本在各种设备和网络环境下的表现\n- **平滑过渡**：避免突然的全量更新对服务器造成的压力峰值\n- **快速止损**：一旦发现问题，可以立即停止灰度，将影响范围控制在最小\n\n### 工作原理\n\n当你设置了灰度比例（如 10%）后，检查更新时会根据每个用户的设备 UUID 进行哈希计算，确定该用户是否在灰度范围内：\n\n- 灰度范围内的用户会收到新版本的更新推送\n- 灰度范围外的用户会收到上一个全量版本（如果有），或显示为已是最新\n- 同一用户的灰度状态是稳定的，不会因为多次检查更新而变化\n\n### 使用方法\n\n#### 通过网页端操作\n\n1. 登录 [Pushy 管理后台]()\n2. 选择对应的应用和原生包版本\n3. 点击\"发布\"按钮\n4. 选择灰度发布比例\n\n#### 通过命令行操作\n\n请查看[命令行工具文档中的 rollout 参数]()\n\n### 注意事项\n\n:::warning\n**重要提示**：灰度版本与全量版本是独立的绑定关系。\n:::\n\n- **同时只能有一个灰度版本**：每个原生包版本只能绑定一个灰度热更版本（比例小于100%）和一个全量热更版本\n- **优先级**：如果同时存在灰度版本和全量版本，灰度范围内命中的用户会收到灰度版本，没有命中的用户会收到全量版本\n- **提升为全量**：将灰度比例设置为 100% 后，该版本会自动提升为全量版本，替换原有的全量版本\n- **客户端版本要求**：`react-native-update` >= 10.32.0 才能支持同时发布灰度和全量版本。\n","routePath":"/docs/publish","lang":"en","toc":[{"id":"发布原生基准版本","text":"发布原生基准版本","depth":2,"charIndex":1565},{"id":"ios","text":"iOS","depth":3,"charIndex":1578},{"id":"android","text":"Android","depth":3,"charIndex":2183},{"id":"harmony","text":"Harmony","depth":3,"charIndex":2820},{"id":"发布热更新版本","text":"发布热更新版本","depth":2,"charIndex":3376},{"id":"灰度发布","text":"灰度发布","depth":2,"charIndex":4974},{"id":"什么是灰度发布","text":"什么是灰度发布","depth":3,"charIndex":5041},{"id":"灰度发布的作用","text":"灰度发布的作用","depth":3,"charIndex":5135},{"id":"工作原理","text":"工作原理","depth":3,"charIndex":5309},{"id":"使用方法","text":"使用方法","depth":3,"charIndex":5469},{"id":"通过网页端操作","text":"通过网页端操作","depth":4,"charIndex":5479},{"id":"通过命令行操作","text":"通过命令行操作","depth":4,"charIndex":5556},{"id":"注意事项","text":"注意事项","depth":3,"charIndex":5599}],"frontmatter":{"order":2,"title":"发布热更新","type":"快速入门"},"version":""},{"title":"安装与使用 Skill","content":"本文介绍如何安装并使用 `react-native-update` 的 Skill，帮助你在 AI 编程工具中更高效地完成接入、配置与排查。\n\n## Skill 信息\n\n- Skill 名称：`react-native-update`\n- 源仓库：`reactnativecn/react-native-update-skill`\n\n## 安装（推荐）\n\n安装到当前环境支持的所有 Agent：\n\n```bash\nnpx skills add reactnativecn/react-native-update-skill --skill react-native-update -a '*'\n```\n\n仅安装到 Claude Code：\n\n```bash\nnpx skills add reactnativecn/react-native-update-skill --skill react-native-update -a claude-code\n```\n\n## 更新 Skill\n\n```bash\nnpx skills check\nnpx skills update\n```\n\n## 使用方式\n\n安装后，可以直接向 AI 助手提出接入需求，例如：\n\n- 在 Expo 项目中接入 `react-native-update`\n- 在 class 组件根节点中完成接入改造\n- 配置白名单灰度发布策略\n- 排查“热更新未生效”问题\n\n## Skill 覆盖内容\n\n- RN CLI / Expo 接入流程\n- `update.json` 与 `appKey` 配置检查\n- iOS / Android 关键改动提示\n- 更新策略建议（`checkStrategy` / `updateStrategy`）\n- 常见冲突排查（如 `expo-updates`）\n- class 组件与白名单示例\n\n## 相关链接\n\n- 仓库： <a href=\"https://github.com/reactnativecn/react-native-update-skill\" target=\"_blank\">\n  [https://github.com/reactnativecn/react-native-update-skill]() </a>\n- ClawHub 页面（可选）： <a href=\"https://clawhub.ai/skills/react-native-update\" target=\"_blank\">\n  [https://clawhub.ai/skills/react-native-update]() </a>\n","routePath":"/docs/skills","lang":"en","toc":[{"id":"skill-信息","text":"Skill 信息","depth":2,"charIndex":72},{"id":"安装推荐","text":"安装（推荐）","depth":2,"charIndex":167},{"id":"更新-skill","text":"更新 Skill","depth":2,"charIndex":432},{"id":"使用方式","text":"使用方式","depth":2,"charIndex":493},{"id":"skill-覆盖内容","text":"Skill 覆盖内容","depth":2,"charIndex":619},{"id":"相关链接","text":"相关链接","depth":2,"charIndex":800}],"frontmatter":{"order":9,"title":"安装与使用 Skill","type":"进阶指南"},"version":""},{"title":"","content":"<Home />\n","routePath":"/","lang":"en","toc":[],"frontmatter":{"pageType":"custom"},"version":""},{"title":"价格","content":"<Pricing />\n<Footer />\n","routePath":"/pricing","lang":"en","toc":[],"frontmatter":{"pageType":"custom","title":"价格"},"version":""}]